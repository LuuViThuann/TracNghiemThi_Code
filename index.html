<!DOCTYPE html>
<html lang="vi">
<head>
  <link rel="icon" href="/asset/img/tom.svg" type="image/png">
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>TOM - IT</title>
  <link rel="stylesheet" href="asset/css/style.css">
</head>
<body>
  <div class="container">
    <div class="tabs">
      <button class="tab active" data-chapter="0">THIẾT KẾ PHẦN MỀM</button>
      <button class="tab" data-chapter="1">ĐIỆN TOÁN ĐÁM MÂY</button>
      <button class="tab" data-chapter="2">LẬP TRÌNH DI ĐỘNG</button>
      
    
    </div>

    <div class="container-all">
      <div class="quiz-container">
        <div class="logo">
          <img src="asset/img/dnc.jpg" alt="Logo">
        </div>
        <div class="title">Trắc nghiệm ôn thi</div>
        <div id="progress"></div>
        <div id="quiz"></div>
        <div class="controls">
          <button id="prevBtn">⏪ Quay lại</button>
          <button id="nextBtn">⏭ Tiếp theo</button>
        </div>
      </div>
      <div class="grid-container">
        <div class="question-grid" id="questionGrid"></div>
      </div>
    </div>
   
  </div>
  <script>
    const chapters = [
      // THIẾT KẾ PHẦN MỀM
      [
    {
 "q": "Câu 21: Quá trình xác định các thành phần và cách chúng tương tác trong phần mềm được gọi là gì?",
 "options": ["Kiến trúc phần mềm", "Thiết kế chi tiết", "Phân tích yêu cầu", "Triển khai hệ thống"],
 "answer": 0
},
{
 "q": "Câu 22: Lý do quan trọng nhất để có một thiết kế phần mềm tốt là gì, đặc biệt liên quan đến chi phí bảo trì?",
 "options": ["Tăng tốc độ phát triển", "Giảm chi phí bảo trì lâu dài", "Dễ tuyển dụng lập trình viên", "Tăng tính thẩm mỹ giao diện"],
 "answer": 1
},
{
 "q": "Câu 23: UML giúp hỗ trợ công việc gì trong thiết kế phần mềm hướng đối tượng?",
 "options": ["Kiểm thử tự động", "Mô hình hóa hệ thống theo hướng đối tượng", "Quản lý cơ sở dữ liệu", "Tối ưu hiệu năng"],
 "answer": 1
},
{
 "q": "Câu 24: Loại biểu đồ nào trong UML thể hiện các lớp, thuộc tính và phương thức chủ yếu?",
 "options": ["Biểu đồ trình tự", "Biểu đồ lớp", "Biểu đồ hoạt động", "Biểu đồ trạng thái"],
 "answer": 1
},
{
 "q": "Câu 25: Biểu đồ nào mô tả trình tự tương tác giữa các đối tượng theo thời gian trong hệ thống?",
 "options": ["Biểu đồ lớp", "Biểu đồ hoạt động", "Biểu đồ trình tự", "Biểu đồ thành phần"],
 "answer": 2
},
{
 "q": "Câu 26: Mẫu thiết kế được định nghĩa là gì trong phát triển phần mềm?",
 "options": ["Mã nguồn mẫu", "Giải pháp đã được kiểm chứng cho một vấn đề thiết kế phổ biến", "Công cụ tự động hóa", "Tài liệu yêu cầu"],
 "answer": 1
},
{
 "q": "Câu 27: Bộ sưu tập mẫu thiết kế kinh điển phổ biến có bao nhiêu mẫu?",
 "options": ["15 mẫu", "20 mẫu", "23 mẫu", "25 mẫu"],
 "answer": 2
},
{
 "q": "Câu 27: Tác giả bộ sưu tập 23 mẫu thiết kế kinh điển được gọi là gì?",
 "options": ["Gang of Five", "Gang of Four", "Group of Three", "Team of Six"],
 "answer": 1
},
{
 "q": "Câu 28: Các mẫu thiết kế thuộc nhóm tạo lập (Creational) chủ yếu giải quyết vấn đề gì?",
 "options": ["Cấu trúc lớp", "Tương tác giữa các đối tượng", "Cách tạo đối tượng một cách linh hoạt", "Quản lý trạng thái"],
 "answer": 2
},
{
 "q": "Câu 29: Mẫu thiết kế nào đảm bảo chỉ tồn tại một thể hiện duy nhất của một lớp trong toàn bộ ứng dụng?",
 "options": ["Factory Method", "Singleton", "Observer", "Prototype"],
 "answer": 1
},
{
 "q": "Câu 30: Mẫu thiết kế nào giúp tạo đối tượng một cách linh hoạt mà không làm phức tạp lớp chứa nó?",
 "options": ["Singleton", "Factory Method", "Decorator", "Strategy"],
 "answer": 1
},
{
 "q": "Mẫu thiết kế nào thuộc nhóm Creational, dùng để tạo ra một họ các đối tượng liên quan?",
 "options": ["Builder", "Abstract Factory", "Prototype", "Singleton"],
 "answer": 1
},
{
 "q": "Biểu đồ nào trong UML mô tả các trạng thái và sự chuyển đổi trạng thái của một đối tượng?",
 "options": ["Biểu đồ trình tự", "Biểu đồ lớp", "Biểu đồ trạng thái", "Biểu đồ thành phần"],
 "answer": 2
},
{
 "q": "Mẫu thiết kế nào cho phép thay đổi hành vi của một đối tượng tại thời điểm chạy?",
 "options": ["Strategy", "Template Method", "State", "Command"],
 "answer": 0
},
{
 "q": "Mẫu thiết kế nào được sử dụng để đơn giản hóa giao diện với một hệ thống con phức tạp?",
 "options": ["Adapter", "Facade", "Proxy", "Bridge"],
 "answer": 1
},
{
 "q": "Mẫu thiết kế Observer thuộc nhóm nào?",
 "options": ["Creational", "Structural", "Behavioral", "Architectural"],
 "answer": 2
},
{
 "q": "Mẫu thiết kế nào cho phép xây dựng đối tượng phức tạp từng bước một?",
 "options": ["Factory Method", "Builder", "Prototype", "Abstract Factory"],
 "answer": 1
},
{
 "q": "Trong UML, mối quan hệ 'kế thừa' được biểu diễn bằng biểu tượng nào?",
 "options": ["Mũi tên rỗng", "Đường thẳng có dấu kim cương", "Mũi tên có dấu tam giác rỗng", "Đường nét đứt"],
 "answer": 2
},
{
 "q": "Mẫu thiết kế nào giúp tránh sự phụ thuộc trực tiếp giữa các lớp bằng cách dùng trung gian?",
 "options": ["Mediator", "Proxy", "Adapter", "Decorator"],
 "answer": 0
},
{
 "q": "Nguyên tắc thiết kế 'tách biệt việc khởi tạo khỏi biểu diễn' liên quan chặt chẽ đến mẫu nào?",
 "options": ["Singleton", "Builder", "Factory Method", "Prototype"],
 "answer": 1
},
{
 "q": "Câu 10: Nguy cơ lớn nhất khi phát triển phần mềm tùy chỉnh là gì?",
 "options": ["Thiếu tài liệu", "Chi phí cao và vượt ngân sách", "Không có giao diện đẹp", "Không hỗ trợ di động"],
 "answer": 1
},
{
 "q": "Câu 11: Lợi ích nổi bật của phần mềm đóng gói so với tùy chỉnh?",
 "options": ["Hoàn toàn phù hợp nghiệp vụ", "Triển khai nhanh, chi phí ban đầu thấp", "Dễ bảo trì hơn", "Không cần đào tạo"],
 "answer": 1
},
{
 "q": "Câu 12: Rủi ro phổ biến khi dùng phần mềm đóng gói?",
 "options": ["Chi phí cao", "Không phù hợp hoàn toàn với quy trình doanh nghiệp", "Khó cập nhật", "Bảo mật kém"],
 "answer": 1
},
{
 "q": "Câu 13: Tác động tích cực của outsourcing đến doanh nghiệp?",
 "options": ["Tăng chi phí nhân sự", "Tiếp cận công nghệ mới và chuyên gia", "Mất kiểm soát dự án", "Tăng thời gian phát triển"],
 "answer": 1
},
{
 "q": "Câu 14: Vấn đề phổ biến khi thuê ngoài offshore?",
 "options": ["Chi phí thấp hơn", "Múi giờ và rào cản văn hóa", "Chất lượng luôn cao", "Dễ quản lý hơn"],
 "answer": 1
},
{
 "q": "Câu 15: Công việc chính trong tích hợp hệ thống không bao gồm?",
 "options": ["Chuyển đổi dữ liệu", "Thiết kế giao diện người dùng", "Kiểm thử tích hợp", "Phân tích hệ thống cũ"],
 "answer": 1
},
{
 "q": "Câu 16: Object Wrapper dùng để làm gì trong tích hợp hệ thống?",
 "options": ["Tăng tốc độ hệ thống", "Đóng gói hệ thống cũ để giao tiếp với hệ thống mới", "Thay thế hoàn toàn hệ thống cũ", "Tạo giao diện người dùng"],
 "answer": 1
},
{
 "q": "Câu 17: Verification đảm bảo điều gì?",
 "options": ["Sản phẩm đúng yêu cầu người dùng", "Xây dựng sản phẩm đúng cách", "Hiệu năng cao", "Bảo mật tốt"],
 "answer": 1
},
{
 "q": "Câu 18: Validation xác nhận điều gì?",
 "options": ["Tuân thủ tiêu chuẩn coding", "Xây dựng đúng sản phẩm người dùng cần", "Tốc độ xử lý nhanh", "Dễ bảo trì"],
 "answer": 1
},
{
 "q": "Câu 19: Lợi ích quan trọng nhất của prototyping?",
 "options": ["Giảm chi phí lập trình", "Làm rõ yêu cầu và nhận phản hồi sớm", "Tăng tốc độ triển khai", "Tự động tạo mã nguồn"],
 "answer": 1
},
{
 "q": "Câu 20: Yếu tố phi chức năng nào sau đây KHÔNG cần xem xét khi thiết kế?",
 "options": ["Hiệu năng", "Màu sắc giao diện", "Bảo mật", "Khả năng mở rộng"],
 "answer": 1
},
{
 "q": "Câu 21: Quá trình xác định thành phần và tương tác trong phần mềm gọi là?",
 "options": ["Thiết kế chi tiết", "Kiến trúc phần mềm", "Phân tích yêu cầu", "Kiểm thử hệ thống"],
 "answer": 1
},
{
 "q": "Phần mềm đóng gói thường được gọi là gì?",
 "options": ["Custom Software", "COTS", "Open Source", "Legacy System"],
 "answer": 1
},
{
 "q": "Verification trả lời câu hỏi nào?",
 "options": ["Are we building the right product?", "Are we building the product right?", "Is the system secure?", "Is the UI beautiful?"],
 "answer": 1
},
{
 "q": "Validation trả lời câu hỏi nào?",
 "options": ["Are we building the product right?", "Are we building the right product?", "Is the code optimized?", "Is the database normalized?"],
 "answer": 1
},
{
 "q": "Middleware thường được dùng trong giai đoạn nào?",
 "options": ["Phân tích yêu cầu", "Tích hợp hệ thống", "Thiết kế giao diện", "Viết tài liệu"],
 "answer": 1
},
{
 "q": "Yếu tố nào KHÔNG phải là phi chức năng?",
 "options": ["Tính đăng nhập người dùng", "Hiệu năng tải trang", "Bảo mật dữ liệu", "Khả năng mở rộng"],
 "answer": 0
},
{
 "q": "Outsourcing offshore thường gặp khó khăn gì lớn nhất?",
 "options": ["Chi phí cao", "Múi giờ và giao tiếp", "Công nghệ lạc hậu", "Thiếu nhân sự"],
 "answer": 1
},
{
 "q": "Prototyping thuộc giai đoạn nào trong vòng đời phần mềm?",
 "options": ["Triển khai", "Phân tích và thiết kế", "Bảo trì", "Kiểm thử"],
 "answer": 1
},
{
 "q": "Kiến trúc phần mềm tập trung vào cấp độ nào?",
 "options": ["Chi tiết mã nguồn", "Cấu trúc cấp cao của hệ thống", "Giao diện người dùng", "Cơ sở dữ liệu"],
 "answer": 1
},
{
 "q": "Câu 1: Phân tích tập trung giải quyết vấn đề nào trong dự án phần mềm?",
 "options": ["Cách viết mã nguồn", "Hiểu đúng yêu cầu người dùng và nghiệp vụ", "Tối ưu hiệu năng", "Thiết kế giao diện"],
 "answer": 1
},
{
 "q": "Câu 1: Khi phân tích, ta cần trả lời câu hỏi nào?",
 "options": ["Làm như thế nào?", "Hệ thống cần làm gì?", "Dùng công nghệ gì?", "Chi phí bao nhiêu?"],
 "answer": 1
},
{
 "q": "Câu 2: Giai đoạn thiết kế nhằm mục đích gì?",
 "options": ["Thu thập yêu cầu", "Chuyển yêu cầu thành bản thiết kế kỹ thuật", "Viết mã nguồn", "Kiểm thử hệ thống"],
 "answer": 1
},
{
 "q": "Câu 3: Mối quan hệ giữa phân tích và thiết kế là gì?",
 "options": ["Phân tích là đầu ra của thiết kế", "Thiết kế là đầu vào của phân tích", "Phân tích là đầu vào, thiết kế là đầu ra", "Hai giai đoạn độc lập"],
 "answer": 2
},
{
 "q": "Câu 4: Phương pháp lặp (Agile) thực hiện phân tích và thiết kế như thế nào?",
 "options": ["Làm toàn bộ một lần", "Từng phần nhỏ qua các vòng lặp", "Chỉ phân tích, không thiết kế", "Thiết kế trước, phân tích sau"],
 "answer": 1
},
{
 "q": "Câu 5: Quá trình chuyển mô hình thiết kế thành phần mềm thực thi gọi là gì?",
 "options": ["Phân tích", "Thiết kế", "Triển khai (Implementation)", "Kiểm thử"],
 "answer": 2
},
{
 "q": "Câu 6: Factoring trong tổ chức mô hình có tác dụng gì?",
 "options": ["Chia nhỏ hệ thống", "Tách trách nhiệm chung để tái sử dụng", "Tăng tốc độ chạy", "Tạo giao diện"],
 "answer": 1
},
{
 "q": "Câu 6: Partitioning có tác dụng gì?",
 "options": ["Tái sử dụng mã", "Chia hệ thống thành các phân vùng độc lập", "Tăng bảo mật", "Tự động tạo tài liệu"],
 "answer": 1
},
{
 "q": "Câu 7: Lớp nào trong kiến trúc phân tầng xử lý nghiệp vụ?",
 "options": ["Presentation Layer", "Business Logic Layer", "Data Access Layer", "Infrastructure Layer"],
 "answer": 1
},
{
 "q": "Câu 8: Mục đích chính của kế thừa trong mô hình lớp?",
 "options": ["Tăng tốc độ", "Tái sử dụng mã và tổ chức phân cấp", "Tạo giao diện", "Lưu trữ dữ liệu"],
 "answer": 1
},
{
 "q": "Câu 9: Lợi thế lớn nhất của phần mềm tùy chỉnh?",
 "options": ["Chi phí thấp", "Phù hợp 100% với quy trình doanh nghiệp", "Triển khai nhanh", "Dễ bảo trì"],
 "answer": 1
},
{
 "q": "Câu 10: Nguy cơ lớn nhất của phần mềm tùy chỉnh?",
 "options": ["Không đẹp", "Chi phí cao và vượt ngân sách", "Không hỗ trợ mobile", "Thiếu tài liệu"],
 "answer": 1
},
{
 "q": "Giai đoạn nào trả lời câu hỏi 'What?'",
 "options": ["Thiết kế", "Phân tích", "Triển khai", "Kiểm thử"],
 "answer": 1
},
{
 "q": "Giai đoạn nào trả lời câu hỏi 'How?'",
 "options": ["Phân tích", "Thiết kế", "Bảo trì", "Phân tích yêu cầu"],
 "answer": 1
},
{
 "q": "Kiến trúc phân tầng gồm bao nhiêu lớp cơ bản?",
 "options": ["2 lớp", "3 lớp", "4 lớp", "5 lớp"],
 "answer": 1
},
{
 "q": "Phương pháp nào khuyến khích làm việc lặp và phản hồi nhanh?",
 "options": ["Waterfall", "Spiral", "Agile", "V-Model"],
 "answer": 2
},
{
 "q": "Kế thừa hỗ trợ nguyên tắc nào trong OOP?",
 "options": ["Đóng gói", "Đa hình", "Trừu tượng", "Tất cả"],
 "answer": 3
},
{
 "q": "Business Logic Layer còn được gọi là gì?",
 "options": ["View Layer", "Service Layer", "Repository Layer", "Controller Layer"],
 "answer": 1
},
{
 "q": "Scope creep thường xảy ra ở giai đoạn nào?",
 "options": ["Thiết kế", "Phân tích và phát triển tùy chỉnh", "Triển khai", "Bảo trì"],
 "answer": 1
},
{
 "q": "Modularity được cải thiện nhờ kỹ thuật nào?",
 "options": ["Factoring và Partitioning", "Inheritance và Polymorphism", "Loop và Condition", "SQL và NoSQL"],
 "answer": 0
},
{
 "q": "Câu 31: Hậu quả của việc dùng quá nhiều mẫu thiết kế không phù hợp?",
 "options": ["Tăng hiệu năng", "Over-engineering, hệ thống phức tạp", "Giảm chi phí", "Dễ bảo trì hơn"],
 "answer": 1
},
{
 "q": "Câu 32: SCM viết tắt của gì và có nhiệm vụ chính là gì?",
 "options": ["Source Code Management - Quản lý mã nguồn", "Software Configuration Management - Quản lý cấu hình phần mềm", "System Control Module - Điều khiển hệ thống", "Security Compliance Model - Mô hình tuân thủ bảo mật"],
 "answer": 1
},
{
 "q": "Câu 33: Hệ thống quản lý phiên bản phổ biến nhất hiện nay?",
 "options": ["SVN", "Mercurial", "Git", "CVS"],
 "answer": 2
},
{
 "q": "Câu 34: Tính năng nào của Git giúp quản lý quy trình phát triển tốt nhất?",
 "options": ["Commit nhanh", "Branching & Merging", "Tự động backup", "Giao diện đẹp"],
 "answer": 1
},
{
 "q": "Câu 35: Khó khăn lớn nhất khi xây dựng thành phần tái sử dụng?",
 "options": ["Viết tài liệu", "Thiết kế tổng quát mà vẫn hiệu quả", "Tích hợp database", "Tạo giao diện"],
 "answer": 1
},
{
 "q": "Câu 36: Kiến trúc phần mềm xác định điều gì?",
 "options": ["Chi tiết mã nguồn", "Cấu trúc cấp cao và tương tác thành phần", "Màu sắc giao diện", "Cơ sở dữ liệu"],
 "answer": 1
},
{
 "q": "Câu 37: Tầng nào trong kiến trúc 3 tầng xử lý quy tắc nghiệp vụ?",
 "options": ["Presentation Layer", "Business Logic Layer", "Data Access Layer", "Network Layer"],
 "answer": 1
},
{
 "q": "Câu 38: Đặc điểm nổi bật của Microservices?",
 "options": ["Tất cả dịch vụ dùng chung database", "Mỗi dịch vụ độc lập, deploy riêng, giao tiếp qua API", "Chỉ dùng một ngôn ngữ lập trình", "Không cần kiểm soát phiên bản"],
 "answer": 1
},
{
 "q": "Câu 39: Mô hình CIA gồm 3 nguyên tắc nào?",
 "options": ["Cost, Integration, Automation", "Confidentiality, Integrity, Availability", "Control, Identity, Access", "Cloud, Internet, Application"],
 "answer": 1
},
{
 "q": "Câu 40: Điểm mạnh lớn nhất của Cloud so với On-Premise?",
 "options": ["Bảo mật tốt hơn", "Khả năng mở rộng linh hoạt và giảm chi phí ban đầu", "Tốc độ truy cập nhanh hơn", "Không cần bảo trì"],
 "answer": 1
},
{
 "q": "Git là hệ thống quản lý phiên bản kiểu gì?",
 "options": ["Tập trung (Centralized)", "Phân tán (Distributed)", "Tệp đơn (Single-file)", "Cơ sở dữ liệu"],
 "answer": 1
},
{
 "q": "Nguyên tắc nào trong CIA đảm bảo dữ liệu không bị sửa đổi trái phép?",
 "options": ["Confidentiality", "Integrity", "Availability", "Authentication"],
 "answer": 1
},
{
 "q": "Trong Microservices, mỗi dịch vụ thường có:",
 "options": ["Cơ sở dữ liệu chung", "Cơ sở dữ liệu riêng", "Không cần database", "Chỉ dùng file"],
 "answer": 1
},
{
 "q": "Kiến trúc 3 tầng còn được gọi là:",
 "options": ["Monolith", "Client-Server", "N-tier", "Peer-to-Peer"],
 "answer": 2
},
{
 "q": "Pull Request dùng để làm gì trong Git?",
 "options": ["Tự động deploy", "Review và merge code", "Xóa nhánh", "Tạo backup"],
 "answer": 1
},
{
 "q": "Component reusability bị ảnh hưởng bởi yếu tố nào nhất?",
 "options": ["Màu sắc", "Độ tổng quát và không phụ thuộc cụ thể", "Số lượng dòng code", "Tên biến"],
 "answer": 1
},
{
 "q": "Cloud computing chuyển chi phí từ ___ sang ___",
 "options": ["OpEx → CapEx", "CapEx → OpEx", "Revenue → Profit", "Fixed → Variable"],
 "answer": 1
},
{
 "q": "SCM giúp đảm bảo điều gì quan trọng trong dự án?",
 "options": ["Giao diện đẹp", "Tính truy vết (traceability)", "Tốc độ tải trang", "Số lượng người dùng"],
 "answer": 1
},
{
 "q": "Nguyên tắc 'Availability' trong CIA có nghĩa là:",
 "options": ["Dữ liệu bí mật", "Hệ thống luôn sẵn sàng", "Dữ liệu chính xác", "Xác thực người dùng"],
 "answer": 1
},
{
 "q": "Kiến trúc phần mềm là cấp độ thiết kế nào?",
 "options": ["Chi tiết (low-level)", "Cao cấp (high-level)", "Giao diện người dùng", "Cơ sở dữ liệu"],
 "answer": 1
},
{
 "q": "Câu 41: Mục đích chính của thiết kế giao diện người dùng là gì?",
 "options": ["Tăng tốc độ tải trang", "Tạo trải nghiệm dễ dùng và hiệu quả", "Hỗ trợ nhiều ngôn ngữ", "Tích hợp AI"],
 "answer": 1
},
{
 "q": "Câu 42: Yếu tố trọng tâm trong thiết kế giao diện là gì?",
 "options": ["Công nghệ mới", "Thiết kế lấy người dùng làm trung tâm (UCD)", "Màu sắc đẹp", "Hiệu ứng động"],
 "answer": 1
},
{
 "q": "Câu 43: Lợi ích lớn nhất của giao diện nhất quán?",
 "options": ["Tăng dung lượng", "Giảm thời gian học và lỗi người dùng", "Tăng hiệu năng", "Dễ code hơn"],
 "answer": 1
},
{
 "q": "Câu 44: Phản hồi hệ thống trong UI giúp người dùng điều gì?",
 "options": ["Biết hành động đã được thực hiện", "Tăng tốc độ click", "Thay đổi màu nền", "Tự động lưu"],
 "answer": 0
},
{
 "q": "Câu 45: Ví dụ điển hình cho thiết kế tối giản?",
 "options": ["Facebook News Feed", "Google Search Homepage", "Netflix Dashboard", "Amazon Product Page"],
 "answer": 1
},
{
 "q": "Câu 46: Nguyên tắc linh hoạt trong UI phục vụ nhóm nào?",
 "options": ["Chỉ lập trình viên", "Người dùng có nhu cầu và khả năng khác nhau", "Chỉ quản trị viên", "Chỉ người dùng mobile"],
 "answer": 1
},
{
 "q": "Câu 47: Cách nào giảm lỗi người dùng trong giao diện?",
 "options": ["Thêm nhiều nút", "Xác nhận trước hành động nguy hiểm", "Tăng độ sáng màn hình", "Dùng font nhỏ"],
 "answer": 1
},
{
 "q": "Câu 48: Quy trình thiết kế UI thường là:",
 "options": ["Thiết kế → code → xong", "Lặp đi lặp lại với kiểm thử người dùng", "Chỉ làm một lần", "Dựa vào cảm tính"],
 "answer": 1
},
{
 "q": "Câu 49: Bước đầu tiên trước khi thiết kế giao diện?",
 "options": ["Vẽ wireframe", "Hiểu người dùng và yêu cầu", "Chọn màu sắc", "Viết code"],
 "answer": 1
},
{
 "q": "Câu 50: Wireframe chủ yếu thể hiện gì?",
 "options": ["Màu sắc và hình ảnh", "Bố cục và cấu trúc chức năng", "Hiệu ứng hover", "Font chữ"],
 "answer": 1
},
{
 "q": "Thiết kế lấy người dùng làm trung tâm còn gọi là?",
 "options": ["UCD", "UID", "UXD", "GDD"],
 "answer": 0
},
{
 "q": "Phản hồi hệ thống có thể là dạng nào?",
 "options": ["Chỉ thông báo lỗi", "Loading spinner, toast message, progress bar", "Chỉ âm thanh", "Chỉ thay đổi màu"],
 "answer": 1
},
{
 "q": "Nguyên tắc nào yêu cầu giao diện phải dễ học, dễ nhớ?",
 "options": ["Consistency", "Minimalism", "Learnability", "Flexibility"],
 "answer": 2
},
{
 "q": "Persona trong thiết kế UI là gì?",
 "options": ["Mẫu người dùng giả định", "Tài khoản thật", "Nhân viên công ty", "Lập trình viên"],
 "answer": 0
},
{
 "q": "Usability testing thuộc giai đoạn nào?",
 "options": ["Phân tích yêu cầu", "Sau khi thiết kế và có prototype", "Triển khai sản phẩm", "Bảo trì"],
 "answer": 1
},
{
 "q": "Thiết kế tối giản tuân theo nguyên tắc:",
 "options": ["Less is more", "More is better", "Fast is best", "Color is key"],
 "answer": 0
},
{
 "q": "Tooltip dùng để làm gì trong UI?",
 "options": ["Tăng hiệu năng", "Hướng dẫn người dùng khi hover", "Lưu dữ liệu", "Tự động điền form"],
 "answer": 1
},
{
 "q": "Bố cục wireframe thường được vẽ bằng công cụ nào?",
 "options": ["Photoshop", "Figma, Balsamiq, Sketch", "Visual Studio", "Excel"],
 "answer": 1
},
{
 "q": "Nguyên tắc 'Consistency' trong UI có nghĩa là:",
 "options": ["Mọi thứ phải giống nhau", "Giao diện thống nhất về kiểu dáng và hành vi", "Tốc độ xử lý nhanh", "Hỗ trợ đa nền tảng"],
 "answer": 1
},
{
 "q": "Mục tiêu của UCD là:",
 "options": ["Làm đẹp giao diện", "Đáp ứng nhu cầu người dùng thực sự", "Giảm chi phí code", "Tăng doanh thu"],
 "answer": 1
},
{
 "q": "Câu 51: Khác biệt lớn nhất giữa mockup và wireframe?",
 "options": ["Mockup có màu sắc và hình ảnh, wireframe chỉ bố cục", "Wireframe có thể click, mockup không", "Mockup là bản code, wireframe là bản vẽ", "Không có khác biệt"],
 "answer": 0
},
{
 "q": "Câu 52: Prototype giúp trải nghiệm điều gì của giao diện?",
 "options": ["Màu sắc", "Tính tương tác và luồng người dùng", "Hiệu năng", "Bảo mật"],
 "answer": 1
},
{
 "q": "Câu 53: Đánh giá chuyên gia giao diện dựa trên?",
 "options": ["Cảm tính cá nhân", "Nielsen’s 10 Usability Heuristics", "Số lượng nút bấm", "Độ phân giải màn hình"],
 "answer": 1
},
{
 "q": "Câu 54: Giao diện tương tác chú trọng đến?",
 "options": ["Hiệu ứng 3D", "Hành vi tự nhiên và kỳ vọng người dùng", "Tốc độ tải trang", "Số lượng người dùng"],
 "answer": 1
},
{
 "q": "Câu 55: Mục đích của tính an toàn trong UI tương tác?",
 "options": ["Tăng tốc độ", "Ngăn hành động không thể phục hồi", "Làm đẹp giao diện", "Tự động lưu"],
 "answer": 1
},
{
 "q": "Câu 56: Ràng buộc trong thiết kế tương tác giúp gì?",
 "options": ["Tăng hiệu năng", "Giảm lỗi nhập liệu", "Tăng dung lượng", "Làm chậm hệ thống"],
 "answer": 1
},
{
 "q": "Câu 57: Người dùng cần hỗ trợ gì khi nhập dữ liệu?",
 "options": ["Chỉ ô trống", "Hướng dẫn, phản hồi, gợi ý, xử lý lỗi rõ ràng", "Tự động nhập hộ", "Không cần hỗ trợ"],
 "answer": 1
},
{
 "q": "Câu 58: Khi nhập sai, giao diện nên phản hồi thế nào?",
 "options": ["Tắt ứng dụng", "Thông báo lỗi rõ ràng + hướng dẫn sửa", "Xóa toàn bộ form", "Không phản hồi gì"],
 "answer": 1
},
{
 "q": "Câu 59: Tối ưu backend ảnh hưởng đến UX như thế nào?",
 "options": ["Không ảnh hưởng", "Tăng tốc độ phản hồi → cải thiện UX", "Làm đẹp giao diện", "Tăng bảo mật"],
 "answer": 1
},
{
 "q": "Câu 60: Tại sao cần tách biệt giao diện và logic?",
 "options": ["Giảm dung lượng", "Dễ bảo trì, tái sử dụng, team làm việc song song", "Tăng tốc độ code", "Làm đẹp UI"],
 "answer": 1
},
{
 "q": "Wireframe thuộc mức độ fidelity nào?",
 "options": ["High-fidelity", "Low-fidelity", "No-fidelity", "Full-fidelity"],
 "answer": 1
},
{
 "q": "Heuristic Evaluation do ai thực hiện?",
 "options": ["Người dùng cuối", "Chuyên gia UX", "Lập trình viên", "Quản lý dự án"],
 "answer": 1
},
{
 "q": "Nguyên tắc nào yêu cầu 'hệ thống phải luôn thông báo trạng thái'?",
 "options": ["Visibility of system status", "Match between system and real world", "User control and freedom", "Error prevention"],
 "answer": 0
},
{
 "q": "Placeholder trong form có tác dụng gì?",
 "options": ["Chỉ để trang trí", "Gợi ý định dạng dữ liệu cần nhập", "Lưu dữ liệu", "Tự động điền"],
 "answer": 1
},
{
 "q": "Tính năng 'Undo' thuộc nguyên tắc nào?",
 "options": ["Error prevention", "User control and freedom", "Consistency", "Minimalist design"],
 "answer": 1
},
{
 "q": "Backend chậm gây ra hiện tượng gì ở frontend?",
 "options": ["Màu sắc nhạt", "Loading lâu, giao diện đơ", "Lỗi bảo mật", "Tự động đăng xuất"],
 "answer": 1
},
{
 "q": "Mẫu thiết kế tách UI và logic phổ biến nhất?",
 "options": ["Singleton", "MVC", "Factory", "Observer"],
 "answer": 1
},
{
 "q": "Mockup thường được tạo bằng công cụ nào?",
 "options": ["Excel", "Figma, Adobe XD, Sketch", "Notepad", "Git"],
 "answer": 1
},
{
 "q": "Usability testing khác heuristic evaluation ở điểm nào?",
 "options": ["Do người dùng thật", "Do chuyên gia", "Không cần prototype", "Chỉ xem màu sắc"],
 "answer": 0
},
{
 "q": "Separation of Concerns giúp gì trong phát triển?",
 "options": ["Tăng độ phức tạp", "Tách UI, logic, data → dễ bảo trì", "Giảm số lượng file", "Tăng tốc độ tải"],
 "answer": 1
},
{
 "q": "Câu 61: Đặc tả phương thức theo DbC bao gồm thông tin nào?",
 "options": ["Chỉ tên và tham số", "Tiền/hậu điều kiện, bất biến, ngoại lệ", "Chỉ mã nguồn", "Chỉ giao diện"],
 "answer": 1
},
{
 "q": "Câu 62: Có bao nhiêu loại ràng buộc chính trong thiết kế phần mềm?",
 "options": ["2", "3", "4", "5"],
 "answer": 1
},
{
 "q": "Câu 62: Ba loại ràng buộc chính là gì?",
 "options": ["Input, Output, Error", "Pre, Post, Invariant", "Public, Private, Protected", "Sync, Async, Event"],
 "answer": 1
},
{
 "q": "Câu 63: Tiền điều kiện phải được thỏa mãn khi nào?",
 "options": ["Sau khi phương thức chạy", "Trước khi phương thức được gọi", "Trong khi chạy", "Khi có lỗi"],
 "answer": 1
},
{
 "q": "Câu 63: Ai chịu trách nhiệm đảm bảo tiền điều kiện?",
 "options": ["Phương thức", "Người gọi (caller)", "Hệ thống", "Database"],
 "answer": 1
},
{
 "q": "Câu 64: Hậu điều kiện đảm bảo điều gì?",
 "options": ["Input hợp lệ", "Kết quả đúng như cam kết", "Không có lỗi", "Tốc độ nhanh"],
 "answer": 1
},
{
 "q": "Câu 65: Bất biến (invariant) có ý nghĩa gì?",
 "options": ["Chỉ đúng khi khởi tạo", "Luôn đúng suốt vòng đời đối tượng", "Chỉ đúng khi kết thúc", "Không cần kiểm tra"],
 "answer": 1
},
{
 "q": "Câu 66: OCL dùng để làm gì?",
 "options": ["Viết mã nguồn", "Đặc tả ràng buộc chính xác trong UML", "Tạo giao diện", "Kiểm thử hiệu năng"],
 "answer": 1
},
{
 "q": "Câu 67: Trong OCL, 'self' đại diện cho?",
 "options": ["Lớp cha", "Đối tượng hiện tại", "Toàn bộ hệ thống", "Biến toàn cục"],
 "answer": 1
},
{
 "q": "Câu 68: 'inv' trong OCL dùng để biểu đạt?",
 "options": ["Tiền điều kiện", "Hậu điều kiện", "Bất biến lớp", "Phương thức"],
 "answer": 2
},
{
 "q": "Câu 69: '->size()' trong OCL trả về gì?",
 "options": ["Tên phần tử", "Số phần tử trong tập hợp", "Giá trị lớn nhất", "Kiểu dữ liệu"],
 "answer": 1
},
{
 "q": "Câu 70: Đặc điểm nổi bật của kiến trúc tập trung (monolithic)?",
 "options": ["Dễ mở rộng", "Tất cả tập trung một nơi", "Deploy riêng lẻ", "Không cần database"],
 "answer": 1
},
{
 "q": "Design by Contract do ai đề xuất?",
 "options": ["Grady Booch", "Bertrand Meyer", "Martin Fowler", "James Rumbaugh"],
 "answer": 1
},
{
 "q": "OCL là viết tắt của?",
 "options": ["Object Control Language", "Object Constraint Language", "Open Class Library", "Output Control Logic"],
 "answer": 1
},
{
 "q": "Ví dụ về bất biến lớp 'Person'?",
 "options": ["self.name <> ''", "self.age > 18", "self.login()", "self.save()"],
 "answer": 0
},
{
 "q": "Trong OCL, '->forAll()' dùng để làm gì?",
 "options": ["Đếm phần tử", "Kiểm tra tất cả phần tử thỏa điều kiện", "Lấy phần tử đầu", "Sắp xếp"],
 "answer": 1
},
{
 "q": "Kiến trúc tập trung phù hợp nhất với?",
 "options": ["Hệ thống lớn, phức tạp", "Dự án nhỏ, khởi đầu nhanh", "Microservices", "Hệ thống phân tán"],
 "answer": 1
},
{
 "q": "Hậu điều kiện thường dùng từ khóa gì trong Eiffel?",
 "options": ["require", "ensure", "invariant", "check"],
 "answer": 1
},
{
 "q": "OCL thường được dùng kết hợp với mô hình nào?",
 "options": ["ERD", "UML", "BPMN", "DFD"],
 "answer": 1
},
{
 "q": "Monolithic khác microservices ở điểm nào?",
 "options": ["Tốc độ nhanh hơn", "Tất cả trong một ứng dụng duy nhất", "Dễ bảo mật hơn", "Không cần version control"],
 "answer": 1
},
{
 "q": "Câu 71: Lợi ích lớn nhất của mô hình tập trung trong quản lý dữ liệu?",
 "options": ["Tốc độ nhanh", "Tính nhất quán và kiểm soát truy cập tập trung", "Dễ mở rộng", "Không cần backup"],
 "answer": 1
},
{
 "q": "Câu 72: Điểm yếu lớn nhất của mô hình tập trung với hệ thống lớn?",
 "options": ["Chi phí cao", "Điểm nghẽn hiệu năng, khó mở rộng", "Khó bảo mật", "Không hỗ trợ web"],
 "answer": 1
},
{
 "q": "Câu 73: Kiến trúc Client-Server hoạt động theo nguyên tắc?",
 "options": ["Tất cả trên một máy", "Client yêu cầu – Server xử lý", "Chỉ dùng file", "Không cần mạng"],
 "answer": 1
},
{
 "q": "Câu 74: Ứng dụng nào phổ biến nhất dùng mô hình client-server?",
 "options": ["Ứng dụng desktop", "Ứng dụng web", "Game offline", "Hệ thống nhúng"],
 "answer": 1
},
{
 "q": "Câu 75: Ưu điểm của client-server về bảo trì và mở rộng?",
 "options": ["Cập nhật client mỗi lần", "Cập nhật server, client tự động dùng mới", "Không cần cập nhật", "Chỉ mở rộng client"],
 "answer": 1
},
{
 "q": "Câu 76: Kiến trúc phân lớp được xây dựng theo kiểu gì?",
 "options": ["Monolithic", "N-tier / Layered", "Peer-to-Peer", "Event-Driven"],
 "answer": 1
},
{
 "q": "Câu 77: Mô hình phân lớp giúp gì cho phát triển?",
 "options": ["Tăng độ phức tạp", "Tách biệt trách nhiệm, dễ bảo trì, team song song", "Giảm số lượng file", "Tăng tốc độ code"],
 "answer": 1
},
{
 "q": "Câu 78: Nguyên lý nào KHÔNG thuộc nền tảng phân rã hướng đối tượng?",
 "options": ["Encapsulation", "Inheritance", "Polymorphism", "Serialization"],
 "answer": 3
},
{
 "q": "Câu 79: Đóng gói giúp gì về dữ liệu và phụ thuộc?",
 "options": ["Tăng tốc độ", "Ẩn dữ liệu, giảm phụ thuộc, tăng toàn vẹn", "Tự động lưu", "Tăng dung lượng"],
 "answer": 1
},
{
 "q": "Câu 80: Lớp con có thể làm gì với phương thức lớp cha?",
 "options": ["Chỉ xóa", "Kế thừa, ghi đè, mở rộng", "Không làm gì", "Chỉ copy"],
 "answer": 1
},
{
 "q": "Mô hình tập trung còn gọi là?",
 "options": ["Distributed", "Monolithic", "Microservices", "Cloud-native"],
 "answer": 1
},
{
 "q": "Client trong client-server thường đảm nhận tầng nào?",
 "options": ["Data Layer", "Presentation Layer", "Business Layer", "Network Layer"],
 "answer": 1
},
{
 "q": "Kiến trúc 3-tier gồm những tầng nào?",
 "options": ["Client, Server, Database", "Presentation, Business, Data", "Web, App, DB", "UI, API, Storage"],
 "answer": 1
},
{
 "q": "Nguyên lý 'Abstraction' trong OOP có nghĩa là?",
 "options": ["Ẩn chi tiết triển khai", "Tạo nhiều lớp con", "Ghi đè phương thức", "Tách file"],
 "answer": 0
},
{
 "q": "Kế thừa giúp tránh điều gì?",
 "options": ["Lặp lại mã nguồn", "Tăng tốc độ", "Giảm bộ nhớ", "Tự động test"],
 "answer": 0
},
{
 "q": "Trong n-tier, tầng nào xử lý quy tắc nghiệp vụ?",
 "options": ["Presentation", "Business Logic", "Data Access", "Infrastructure"],
 "answer": 1
},
{
 "q": "Load balancing thường được dùng trong mô hình nào?",
 "options": ["Monolithic", "Client-Server", "Peer-to-Peer", "Standalone"],
 "answer": 1
},
{
 "q": "Đóng gói sử dụng từ khóa nào trong Java/C#?",
 "options": ["public", "private/protected", "static", "final"],
 "answer": 1
},
{
 "q": "Polymorphism cho phép điều gì?",
 "options": ["Một phương thức nhiều hành vi", "Một lớp nhiều cha", "Tự động lưu", "Tăng bộ nhớ"],
 "answer": 0
},
{
 "q": "Mô hình phân lớp tuân thủ nguyên lý thiết kế nào?",
 "options": ["SOLID", "KISS", "YAGNI", "DRY"],
 "answer": 0
},
{
 "q": "Câu 81: Chuẩn IEEE giúp gì cho thiết kế phần mềm?",
 "options": ["Tăng tốc độ code", "Khung tài liệu chuẩn, đảm bảo nhất quán và bảo trì", "Tự động tạo giao diện", "Tích hợp AI"],
 "answer": 1
},
{
 "q": "Câu 82: Mục tiêu chính của chuẩn IEEE là gì?",
 "options": ["Giảm chi phí", "Đảm bảo chất lượng, giao tiếp, bảo trì", "Tăng hiệu năng", "Hỗ trợ mobile"],
 "answer": 1
},
{
 "q": "Câu 83: IEEE 1016 quy định về tài liệu gì?",
 "options": ["Yêu cầu phần mềm", "Mô tả thiết kế phần mềm (SDD)", "Kiểm thử", "Triển khai"],
 "answer": 1
},
{
 "q": "Câu 83: IEEE 1016 gồm mấy phần chính?",
 "options": ["2 phần", "3 phần", "4 phần", "5 phần"],
 "answer": 1
},
{
 "q": "Câu 84: Phần thiết kế tổng quát trình bày gì?",
 "options": ["Chi tiết lớp", "Mục tiêu, phạm vi, ràng buộc", "Thuật toán", "Giao diện API"],
 "answer": 1
},
{
 "q": "Câu 85: Phần kiến trúc mô tả gì?",
 "options": ["Màu sắc UI", "Thành phần, mối quan hệ, giao diện, luồng dữ liệu", "Cơ sở dữ liệu", "Code mẫu"],
 "answer": 1
},
{
 "q": "Câu 86: Nguyên tắc nào KHÔNG thuộc thiết kế kiến trúc tốt theo IEEE?",
 "options": ["Modularity", "High Coupling", "Low Coupling", "Information Hiding"],
 "answer": 1
},
{
 "q": "Câu 87: Mô hình Waterfall có đặc điểm gì?",
 "options": ["Lặp đi lặp lại", "Tuần tự tuyến tính, tài liệu đầy đủ mỗi giai đoạn", "Không cần tài liệu", "Chỉ code"],
 "answer": 1
},
{
 "q": "Câu 88: Agile ưu tiên điều gì hơn hết?",
 "options": ["Tài liệu chi tiết", "Cá nhân và tương tác", "Kế hoạch cứng nhắc", "Công cụ đắt tiền"],
 "answer": 1
},
{
 "q": "Câu 89: Chuẩn IEEE và Agile có thể kết hợp như thế nào?",
 "options": ["Không thể kết hợp", "Dùng IEEE làm khung, Agile làm vòng lặp", "Chỉ dùng một cái", "IEEE thay thế Agile"],
 "answer": 1
},
{
 "q": "IEEE 1016 viết tắt của gì?",
 "options": ["Software Design Description", "System Development Document", "Software Deployment Directive", "Standard Design Document"],
 "answer": 0
},
{
 "q": "Phần nào trong IEEE 1016 mô tả lớp và phương thức?",
 "options": ["Tổng quát", "Kiến trúc", "Chi tiết", "Triển khai"],
 "answer": 2
},
{
 "q": "Nguyên tắc 'High Cohesion' có nghĩa là?",
 "options": ["Nhiều phụ thuộc", "Thành phần có trách nhiệm rõ ràng", "Chia nhỏ quá mức", "Tập trung một nơi"],
 "answer": 1
},
{
 "q": "Waterfall phù hợp nhất với dự án nào?",
 "options": ["Yêu cầu thay đổi liên tục", "Yêu cầu rõ ràng, ít thay đổi", "Không cần tài liệu", "Chỉ làm demo"],
 "answer": 1
},
{
 "q": "Agile Manifesto được công bố năm nào?",
 "options": ["1999", "2001", "2005", "2010"],
 "answer": 1
},
{
 "q": "IEEE là tổ chức nào?",
 "options": ["International Engineering", "Institute of Electrical and Electronics Engineers", "Internet Engineering", "Indian Electronics"],
 "answer": 1
},
{
 "q": "Nguyên tắc 'Information Hiding' giúp gì?",
 "options": ["Tăng tốc độ", "Ẩn chi tiết triển khai, giảm phụ thuộc", "Tăng dung lượng", "Tự động test"],
 "answer": 1
},
{
 "q": "Trong Agile, tài liệu được tạo như thế nào?",
 "options": ["Không cần", "Vừa đủ, liên tục cập nhật", "Toàn bộ từ đầu", "Chỉ cuối dự án"],
 "answer": 1
},
{
 "q": "Mục tiêu của IEEE 1016 là gì?",
 "options": ["Tăng tốc độ", "Tạo tài liệu thiết kế đầy đủ, rõ ràng, chuẩn hóa", "Giảm chi phí", "Tự động code"],
 "answer": 1
},
{
 "q": "Kiến trúc tốt phải đảm bảo nguyên tắc nào sau đây?",
 "options": ["Tất cả trong một file", "Low Coupling & High Cohesion", "Không cần tài liệu", "Chỉ dùng một ngôn ngữ"],
 "answer": 1
}

   ],
  
      // ĐIỆN TOÁN ĐÁM MÂY
      [
    {
  "q": "Phát biểu nào sau đây SAI?",
  "options": [
    "Cả B và C đều sai",
    "Hộp cát (sandbox) là một lớp trừu tượng nằm giữa phần mềm với hệ điều hành nhằm tạo môi trường độc lập cho việc thực thi ứng dụng.",
    "Hạ tầng chuyển mạch trong một hệ thống đám mây không thể cô lập được các gói tin truyền thông giữa các máy ảo nằm trên cùng một môi trường phần cứng",
    "Cả B và C đều đúng"
  ],
  "answer": 0
},
{
  "q": "Phát biểu nào sau đây sai?",
  "options": [
    "Các server ảo sử dụng tài nguyên độc lập như một máy chủ vật lý",
    "Ảo hóa hệ thống tức là tiến hành phân chia một máy chủ thành nhiều máy chủ ảo hoặc kết hợp nhiều máy chủ vật lý thành một máy chủ logic",
    "Các server ảo không hề có tài nguyên độc lập như một máy chủ vật lý",
    "Ảo hóa hệ thống tức là tiến hành phân chia một máy chủ thành nhiều máy chủ ảo"
  ],
  "answer": 0
},
{
  "q": "Khi thiết kế chương trình mô phỏng Cloud, bốn thuộc tính được xem xét đến là?",
  "options": [
    "Cả B và D đều sai",
    "Chi phí mỗi bộ xử lý; Chi phí mỗi đơn vị bộ nhớ; Chi phí mỗi đơn vị lưu trữ; Chi phí mỗi đơn vị băng thông sử dụng",
    "Cả B và D đều đúng",
    "Chi phí mỗi bộ xử lý; Chi phí mỗi đơn vị bộ nhớ; Chi phí mỗi máy chủ; Chi phí mỗi trung tâm dữ liệu lớn"
  ],
  "answer": 1
},
{
  "q": "Phát biểu nào sau đây đúng? Ảo hóa cung cấp tính bao đóng vì:",
  "options": [
    "Mọi thao tác cài đặt cập nhật trên nguồn tài nguyên ảo hóa chỉ diễn ra trong phạm vi máy ảo mà không ảnh hưởng hay tác động tới các máy ảo khác, tài nguyên khác không được cấp phát",
    "Mọi thao tác cài đặt cập nhật trên nguồn tài nguyên ảo hóa chỉ diễn ra trong phạm vi máy ảo và ảnh hưởng hay tác động tới các máy ảo khác, tài nguyên khác vẫn được cấp phát",
    "Tất cả đều sai",
    "Mọi thao tác cài đặt cập nhật trên nguồn tài nguyên ảo hóa chỉ diễn ra trong phạm vi máy ảo mà không ảnh hưởng hay tác động tới các máy ảo khác, tài nguyên khác vẫn được cấp phát"
  ],
  "answer": 0
},
{
  "q": "Trung tâm dữ liệu lớn có nguồn gốc?",
  "options": [
    "Từ sự ra đời của mô hình tính toán “khách – chủ”",
    "A và D sai",
    "A và D đúng",
    "Từ các phòng máy tính lớn (main frames)"
  ],
  "answer": 3
},
{
  "q": "Quản lý sự cố bao gồm các bước nào sau đây?",
  "options": [
    "Có quy trình đầy đủ cho việc phát hiện, ghi nhận và xử lý sự cố",
    "Việc kiểm tra sự cố cần được thực hiện thường xuyên",
    "Có các cơ chế hỗ trợ người sử dụng thông báo về sự cố",
    "Tất cả đều đúng"
  ],
  "answer": 3
},
{
  "q": "Dropbox là một ứng dụng của hãng nào sau đây?",
  "options": ["Oracle", "Amazon", "Google", "Tất cả đều sai"],
  "answer": 1
},
{
  "q": "Trên đĩa cứng, đơn vị lưu trữ dữ liệu nhỏ nhất được tính bằng",
  "options": ["Block", "Cluster", "Bit", "Byte"],
  "answer": 0
},
{
  "q": "Kiến trúc CloudSim bao gồm mấy lớp",
  "options": ["4", "5", "2", "3"],
  "answer": 0
},
{
  "q": "Amazon S3 là dịch vụ kho lưu trữ dữ liệu trên nền điện toán đám mây Amazon Web Service, được đưa ra giới thiệu vào năm 2006. Các khái niệm cơ sở trong Amazon S3 bao gồm:",
  "options": [
    "Objects; Buckets; Keys; Regions",
    "Tất cả đều sai",
    "Data; Node; Keys; Regions",
    "Block; NameNode; Keys; Regions"
  ],
  "answer": 0
},
{
  "q": "Bộ phân phối tài nguyên SLA bao gồm bao nhiêu thành phần?",
  "options": ["5", "3", "6", "4"],
  "answer": 2
},
{
  "q": "SLA (Service Level Agreement) được dùng để xác định",
  "options": [
    "Yêu cầu về mức độ đáp ứng của dịch vụ",
    "Yêu cầu về cấp độ dịch vụ",
    "Yêu cầu về chất lượng dịch vụ",
    "Tất cả đều sai"
  ],
  "answer": 2
},
{
  "q": "Tài liệu CSA Cloud Control Matrix phiên bản 3.0 (viết tắt là CSA CCM v3.0) đề xuất một tập hợp bao nhiêu cơ chế kiểm soát an toàn và bảo mật nhằm trợ giúp các nhà cung cấp dịch vụ đám mây dễ dàng ứng phó với các nguy cơ về an toàn bảo mật",
  "options": ["118", "119", "117", "Tất cả đều sai"],
  "answer": 3
},
{
  "q": "Định giá cố định là gì?",
  "options": [
    "Tất cả đều sai",
    "Nhà cung cấp sẽ xác định rõ đặc tả về khả năng tính toán cố định (dung lượng bộ nhớ được cấp phát, loại CPU và tốc độ...)",
    "Ứng dụng phần lớn trong mô hình dịch vụ phần mềm (SaaS) người dùng sẽ tiên đoán trước định mức sử dụng ứng dụng cloud",
    "Được áp dụng phổ biến cho lượng dữ liệu truyền tải, dung lượng bộ nhớ được cấp phát và sử dụng,… cách này uyển chuyển hơn cách trên."
  ],
  "answer": 1
},
{
  "q": "Block size mặc định của HDFS là bao nhiêu?",
  "options": ["Tất cả đều sai", "32 MB", "64 MB", "128 MB"],
  "answer": 2
},
{
  "q": "Quy trình quản lý rủi ro về an toàn và bảo mật bao gồm các bước theo thứ tự sau:",
  "options": [
    "Lập kế hoạch, Triển khai, Đánh giá, Sửa chữa, Duy trì",
    "Lập kế hoạch, Đánh giá, Triển khai, Duy trì",
    "Lập kế hoạch, Triển khai, Đánh giá, Duy trì",
    "Lập kế hoạch, Triển khai, Phát hiện, Đánh giá, Duy trì"
  ],
  "answer": 2
},
{
  "q": "Công nghệ ảo hóa là công nghệ quan trọng nhất trong điện toán đám mây. Công nghệ này cho phép",
  "options": [
    "B và D đúng",
    "Chia nhỏ tài nguyên vật lý để tối ưu hóa hiệu năng sử dụng",
    "B và D sai",
    "Tạo ra các thực thể ảo có tính năng tương đương như các thực thể vật lý"
  ],
  "answer": 0
},
{
  "q": "Kiến trúc Market-oriented cloud bao gồm bao nhiêu thành phần chủ yếu?",
  "options": ["6", "3", "4", "5"],
  "answer": 2
},
{
  "q": "Theo nghiên cứu khảo sát của International Data Corporation (IDC) năm 2009. Có bao nhiêu vấn đề về an toàn và bảo mật trên các tầng dịch vụ đám mây?",
  "options": ["13", "Tất cả đều sai", "11", "12"],
  "answer": 3
},
{
  "q": "Theo định nghĩa của US NIST chứa đựng kiến trúc, an ninh và chiến lược triển khai của đám mây. Số đặc tính cốt lõi của điện toán đám mây là:",
  "options": ["5", "6", "7", "4"],
  "answer": 0
},
{
  "q": "Kiến trúc CloudSim được sắp xếp theo thứ tự từ thấp đến cao như sau:",
  "options": [
    "SimJava, GridSim, CloudSim, User-Interface",
    "SimJava, GridSim, CloudSim, IaaS",
    "SimJava, GridSim, CloudSim, User-Code",
    "SimJava, GridSim, User-Code, CloudSim"
  ],
  "answer": 2
},
{
  "q": "Trên một cluster chạy HDFS, có bao nhiêu loại nút (node)",
  "options": ["3", "4", "5", "2"],
  "answer": 3
},
{
  "q": "Quản lý truy cập là gì?",
  "options": [
    "Cả B và D đều đúng",
    "Quản lý truy cập là thành phần sử dụng thông tin định danh để cho phép và đặt ràng buộc với các truy cập dịch vụ đám mây",
    "Cả B và D đều sai",
    "Quản lý truy cập là sự ràng buộc chặt chẽ và được công bố rõ ràng trong hợp đồng sử dụng dịch vụ (SLA)."
  ],
  "answer": 3
},
{
  "q": "Các loại nút (node) có thể có trên một cluster chạy HDFS là:",
  "options": [
    "Namenode, Indexnode, Datanode",
    "Tất cả đều sai",
    "Namenode, Indexnode, Masternode, Datanode",
    "Namenode, Datanode"
  ],
  "answer": 3
},
{
  "q": "Theo các vấn đề về an toàn và bảo mật thông tin. Các dịch vụ SaaS có thể được xây dựng theo bao nhiêu mô hình?",
  "options": ["6", "Tất cả đều sai", "5", "4"],
  "answer": 1
},
{
  "q": "Nguyên tắc hoạt động của MapReduce là gì?",
  "options": [
    "Hàm Map, lấy đầu vào là một cặp khóa/giá trị và đưa đầu ra là một tập các cặp khóa/giá trị trung gian. Các cặp khóa/giá trị trung gian này sau đó được gộp lại và các cặp khóa/giá trị trung gian có cùng khóa sẽ được chuyển cho hàm Reduce",
    "Tất cả đều sai",
    "Các phép toán lấy đầu vào là một tập các cặp khóa/giá trị, đưa ra nhiều tập khóa/giá trị đầu ra",
    "Tất cả đều đúng"
  ],
  "answer": 0
},
{
  "q": "Phát biểu nào sau đây sai",
  "options": [
    "Hadoop framework của Apache là một nền tảng dùng để phân tích các tập dữ liệu rất lớn",
    "Hadoop MapReduce là một giải thuật dùng để xử lý lưu trữ dữ liệu",
    "Mô hình thực hiện MapReduce có khả năng chịu lỗi cao",
    "MapReduce bao gồm hai hàm cơ bản là Map và Reduce"
  ],
  "answer": 1
},
{
  "q": "Hadoop distributed file system ra đời trên nhu cầu lưu trữ dữ liệu của Nutch. Vậy Nutch là gì?",
  "options": [
    "Nutch là một Node trong nhu cầu lưu trữ dữ liệu",
    "Nutch là tên một dự án Search Engine nguồn mở",
    "Tất cả đều sai",
    "Nutch là một kỹ thuật ra đời dựa trên nhu cầu lưu trữ dữ liệu"
  ],
  "answer": 1
},
{
  "q": "Trong kiến trúc ảo hóa Hosted–based phát biểu nào sau đây đúng",
  "options": [
    "C và D đúng",
    "C và D sai",
    "Không có lớp Hệ điều hành Host;",
    "Không có lớp Hệ thống virtual machine monitor (hypervisor)"
  ],
  "answer": 3
},
{
  "q": "Trong kiến trúc ảo hóa Hypervisor–based phát biểu nào sau đây đúng",
  "options": [
    "B và D đúng",
    "Không có lớp Hệ thống virtual machine monitor (hypervisor)",
    "B và D sai",
    "Không có lớp Hệ điều hành Host"
  ],
  "answer": 3
},
{
  "q": "Trọng tâm của điện toán lưới là gì?",
  "options": [
    "Chia nhỏ dữ liệu lớn để xử lý",
    "Truyền tải dữ liệu lớn",
    "Chia nhỏ dữ liệu lớn để xử lý không phụ thuộc vào không gian và thời gian",
    "Di chuyển một tải công việc đến địa điểm của các tài nguyên điện toán cần thiết để sử dụng"
  ],
  "answer": 3
},
{
  "q": "Theo định nghĩa của US NIST chứa đựng kiến trúc, an ninh và chiến lược triển khai của đám mây. Đặc tính tự phục vụ theo yêu cầu (on-demand self-service) có nghĩa là:",
  "options": [
    "Tất cả đều đúng",
    "Khách hàng với nhu cầu tức thời tại những thời điểm thời gian xác định có thể sử dụng các tài nguyên tính toán một cách tự động, không cần tương tác với con người để cấp phát.",
    "Những tài nguyên tính toán này được phân phối qua mạng Internet và được các ứng dụng client khác nhau sử dụng với những nền tảng không đồng nhất",
    "Đối với người sử dụng, các tài nguyên tính toán được cung cấp tức thời hơn là liên tục, được cung cấp theo nhu cầu để mở rộng hoặc tiết giảm không hạn định tại bất kỳ thời điểm nào"
  ],
  "answer": 1
},
{
  "q": "Các yêu cầu nào sau đây là các yêu cầu của hệ thống, dịch vụ giám sát",
  "options": [
    "Triển khai tự động và nhanh chóng, Giá rẻ, Tối ưu tự động liên tục",
    "Triển khai thủ công và nhanh chóng, Co dãn tự động, Tối ưu tự động liên tục",
    "Triển khai nhanh chóng, Co dãn nhanh chóng, Tối ưu nhanh chóng",
    "Triển khai tự động và nhanh chóng, Co dãn tự động, Tối ưu tự động liên tục"
  ],
  "answer": 3
},
{
  "q": "Định nghĩa một lưới nào sau đây đúng?",
  "options": [
    "Một lưới là một nhóm máy chủ mà trên đó nhiệm vụ lớn được chia thành những tác vụ nhỏ để chạy song song, được xem là một máy vật lý",
    "Một lưới là một nhóm máy chủ mà trên đó nhiệm vụ lớn được chia thành những tác vụ nhỏ để chạy song song, được xem là một máy chủ ảo",
    "Một lưới là một nhóm máy chủ mà trên đó nhiệm vụ lớn được chia thành những tác vụ nhỏ để chạy song song, được xem là nhiều máy chủ ảo",
    "Một lưới là một nhóm máy chủ mà trên đó nhiệm vụ lớn được chia thành những tác vụ nhỏ để chạy tuần tự, được xem là một máy chủ ảo"
  ],
  "answer": 1
},
{
  "q": "SaaS là viết tắt của khái niệm nào sau đây?",
  "options": [
    "Service as a Service (Dịch vụ hướng dịch vụ)",
    "Software as a Service (Phần mềm hướng dịch vụ)",
    "Structure as a Service (Cấu trúc hướng dịch vụ)",
    "Swap as a Service (Trao đổi hướng dịch vụ)"
  ],
  "answer": 1
},
{
  "q": "Kiến trúc ảo hóa có thể chia ra làm mấy loại?",
  "options": ["4", "6", "3", "5"],
  "answer": 2
},
{
  "q": "Kiến trúc hệ thống tập tin phân tán mà một máy chủ trong hệ thống đóng vai trò là máy chủ lưu trữ, cung cấp năng lực lưu trữ của các ổ đĩa cứng cục bộ, hệ thống RAID cho các máy tính khác qua giao thức mạng được viết tắt là",
  "options": ["NTFS", "NFS", "ATFS", "AIFS"],
  "answer": 1
},
{
  "q": "Trong điện toán đám mây kích thước của một cluster sẽ được tính bằng",
  "options": ["Tất cả đều đúng", "8 bit", "Tất cả đều sai", "8 byte"],
  "answer": 2
},
{
  "q": "Phát biểu nào sau đây đúng?",
  "options": [
    "Việc giảm số lượng block của một tập tin sẽ làm tăng khối lượng metadata trên NameNode",
    "Việc sử dụng block size lớn, tức sẽ giảm số lượng block của một tập tin",
    "Việc giảm số lượng block cần đọc sẽ tăng số lượng kết nối cần tạo lên một block",
    "Với block size lớn, client sẽ phải tương tác với DataNode nhiều hơn"
  ],
  "answer": 1
},
{
  "q": "Dữ liệu lớn được đặc tả bằng 4V nào sau đây?",
  "options": [
    "Volume, Velocity, Variety, Value",
    "Tất cả đều sai",
    "Volume, Volatile, Variety, Value",
    "Volume, Velocity, Volatile, Value"
  ],
  "answer": 0
},
{
  "q": "Đâu là một ưu điểm của mô hình Openstack Swift",
  "options": [
    "Chi phí sinh hoạt",
    "Mở mã nguồn",
    "Tất cả đáp án đều đúng",
    "Đội ngũ chuyên gia hỗ trợ nhiều kinh nghiệm"
  ],
  "answer": 1
},
{
  "q": "Đâu là một yếu tố của an toàn các dịch vụ Saas",
  "options": [
    "Truy cập dịch vụ",
    "Ít người thuê đồng thời",
    "Truy cập không đồng thời",
    "Tất cả đáp án đều sai"
  ],
  "answer": 0
},
{
  "q": "Đâu là một viết tắt của nền tảng hướng dịch vụ",
  "options": ["IAAS", "PAAA", "PAAS", "SAAS"],
  "answer": 2
},
{
  "q": "Đâu là một ưu điểm của mô hình Amazon S3",
  "options": [
    "Độ tin cậy cao",
    "Đội ngũ chuyên gia hỗ trợ nhiều kinh nghiệm",
    "Thuật toán truy vấn cực nhanh",
    "Tất cả đáp án đều sai"
  ],
  "answer": 0
},
{
  "q": "Đặc trưng chính của NOSQL",
  "options": [
    "Kết hợp nhiều bảng với nhau thành một bản",
    "Không tổ chức dữ liệu dưới dạng bảng",
    "Tổ chức mỗi bảng là một file dữ liệu",
    "Tất cả đáp án đều sai"
  ],
  "answer": 1
},
{
  "q": "Đâu là ưu điểm của điện toán đám mây",
  "options": [
    "Độ tin cậy tương đối",
    "Tiết kiệm tài nguyên, chi phí",
    "Tất cả đáp án đều sai",
    "Tốc độ chấp nhận được"
  ],
  "answer": 1
},
{
  "q": "Công nghệ ảo hoá là việc",
  "options": [
    "Kết hợp nhiều máy chủ vật lý thành một máy chủ logic",
    "Kết hợp nhiều mạng thành mạng WAN",
    "Kết hợp nhiều máy client thành một máy chung",
    "Tất cả đáp án đều đúng"
  ],
  "answer": 0
},
{
  "q": "Đâu là một nhân tố phụ thuộc trong ảo hoá của điện toán đám mây",
  "options": [
    "Khả năng cấu hình thấp",
    "Nhiều hệ điều hành cùng chạy trên một máy chủ vật lý",
    "Tất cả đáp án đều sai",
    "Khả năng cấu hình cao"
  ],
  "answer": 3
},
{
  "q": "Đây là một đặc điểm của bộ phức tạp của NOSQL",
  "options": [
    "Không đảm bảo theo ACID",
    "Cần đội ngũ chuyên gia nhiều kinh nghiệm",
    "Thuật toán truy vấn",
    "Tất cả các đáp án đều đúng"
  ],
  "answer": 0
},
{
  "q": "Điện toán đám mây chia sẻ tài nguyên thông qua",
  "options": [
    "Các sever vật lý",
    "Kết nối mạng cục bộ",
    "Tất cả các đáp án đều sai",
    "Ảo hoá"
  ],
  "answer": 3
},
{
  "q": "Đâu là một yếu tố của an toàn các dịch vụ IaaS",
  "options": [
    "Giám sát máy ảo",
    "Phần cứng không tương thích",
    "Truy cập không đồng thời",
    "Tất cả các đáp án đều sai"
  ],
  "answer": 0
},
{
  "q": "Thành phần không thể thiếu trong ảo hoá của điện toán đám mây?",
  "options": [
    "Tất cả đáp án đều sai",
    "Bao đóng và liên tục",
    "Trừu tượng và bao đóng",
    "Trừu tượng và hiện thực hoá"
  ],
  "answer": 2
},
{
  "q": "Đâu là một đặc điểm của điện toán đám mây",
  "options": [
    "Tất cả đáp án đều sai",
    "Thỉnh thoảng có thể mất liên lạc",
    "Truy cập tức thời và liên tục",
    "Truy cập hạn chế"
  ],
  "answer": 2
},
{
  "q": "Đâu là một yếu tố của an toàn các dịch vụ IaaS",
  "options": [
    "Nhiều mạng đụng độ",
    "Phần cứng không tương thích",
    "Phục hồi máy ảo",
    "Tất cả các đáp án đều sai"
  ],
  "answer": 2
},
{
  "q": "Đâu là một lỗ hỏng liên quan đến dữ liệu",
  "options": [
    "Tất cả đáp án đều sai",
    "Dữ liệu xoá an toàn",
    "Khả năng cấu hình yếu",
    "Dữ liệu được sao lưu bởi bên thứ ba"
  ],
  "answer": 3
},
{
  "q": "Đâu là yếu tố an toàn của các dịch vụ SaaS",
  "options": [
    "Phần cứng không tương thích",
    "Ít người thuê đồng thời",
    "Bảo mật dữ liệu",
    "Tất cả đáp án đều sai"
  ],
  "answer": 2
},
{
  "q": "Đâu là một dịch vụ đám mây của Azure",
  "options": ["DynamicsERP", "OneCRM", "Dropbox", "Tất cả đáp án đều sai"],
  "answer": 0
},
{
  "q": "CloudBees là cung cấp dịch vụ",
  "options": [
    "Hạ tầng",
    "Tất cả đáp án trên đều đúng",
    "Phần mềm",
    "Nền tảng"
  ],
  "answer": 3
},
{
  "q": "Đâu là một dịch vụ đám mây của Amazon App",
  "options": ["Cloud Drive", "OneDrive", "Dropbox", "Tất cả các đáp án đều sai"],
  "answer": 0
},
{
  "q": "Đâu là một ưu điểm của mô hình Amazon S3",
  "options": [
    "Chi phí linh hoạt",
    "Đội ngũ chuyên gia nhiều kinh nghiệm",
    "Thuật toán truy vấn cực mạnh",
    "Tất cả đáp án đều sai"
  ],
  "answer": 0
},
{
  "q": "Neo4j là NOSQL dạng",
  "options": ["Hướng văn bản", "Key/Value", "Hệ Cột", "Đồ Thị"],
  "answer": 3
},
{
  "q": "Đâu không phải là ưu điểm của điện toán đám mây",
  "options": [
    "Tiết kiệm tài nguyên, chi phí",
    "Nhu cầu lưu trữ",
    "Tất cả các đáp án đều sai",
    "Độ tin cậy cao"
  ],
  "answer": 1
},
{
  "q": "Amazon Dynamo là NOSQL dạng",
  "options": ["Đồ Thị", "Key/Value", "Hướng văn bản", "Hệ Cột"],
  "answer": 1
},
{
  "q": "Amazon Redshift là NOSQL dạng",
  "options": ["Key/Value", "Đồ Thị", "Hệ cột", "Hướng văn bản"],
  "answer": 2
},
{
  "q": "Để kiểm soát truy cập chúng ta dùng giấy phép nào sau đây",
  "options": ["X.600", "X.500", "X.509", "Tất cả đáp án đều sai"],
  "answer": 2
},
{
  "q": "Router sẽ đặt tại đâu trong trung tâm dữ liệu lớn cơ bản",
  "options": [
    "Hạ tầng hướng dịch vụ",
    "Không có đáp án nào đúng",
    "Nền tảng hướng dịch vụ",
    "Tài nguyên phân tán"
  ],
  "answer": 3
},
{
  "q": "Ứng dụng CRM thuộc",
  "options": [
    "Hạ tầng hướng dịch vụ",
    "Phân tích hướng dịch vụ",
    "Nền tảng hướng dịch vụ",
    "Tài nguyên phân tán"
  ],
  "answer": 3
},
{
  "q": "Đâu không phải là một đặc điểm của điện toán đám mây",
  "options": [
    "Truy cập rộng rãi",
    "Tự phục vụ theo yêu cầu",
    "Tất cả đáp án đều sai",
    "Tài nguyên phân tán"
  ],
  "answer": 3
},
{
  "q": "Đâu là một lỗ hổng của dữ liệu trong mạng ảo",
  "options": [
    "Phân tán dữ liệu",
    "Mất dữ liệu do sao chép",
    "Tất cả đáp án đều sai",
    "Dữ liệu không được cập nhật"
  ],
  "answer": 1
},
{
  "q": "Vấn đề nào được quan tâm hàng đầu trong công nghệ đám mây",
  "options": [
    "Chi phí vận hành",
    "Công nghệ triển khai",
    "An toàn và bảo mật",
    "Lập trình"
  ],
  "answer": 2
},
{
  "q": "SQL Azure có mấy chức năng chính",
  "options": ["2", "3", "5", "4"],
  "answer": 3
},
{
  "q": "Trong quá trình lưu trữ của dịch vụ hạ tầng cần chú ý mấy nhóm nhiệm vụ chính",
  "options": ["3", "2", "4", "Không có đáp án đúng"],
  "answer": 0
},
{
  "q": "Onedrive là NOSQL dạng",
  "options": ["Đồ thị", "Key/Value", "Hệ cột", "Không phải là NOSQL"],
  "answer": 3
},
{
  "q": "MISA là một dạng",
  "options": [
    "Phân tích hướng dịch vụ",
    "Hạ tầng hướng dịch vụ",
    "Phần mềm hướng dịch vụ",
    "Nền tảng hướng dịch vụ"
  ],
  "answer": 2
},
{
  "q": "Điểm mạnh của Saas là",
  "options": [
    "Tính linh hoạt",
    "Dễ quản lý",
    "Tính qui mô",
    "Tính tương thích"
  ],
  "answer": 1
},
{
  "q": "Hiện nay Cloud Control Matrix đã được đổi tên thành",
  "options": ["CAS", "Không thay đổi", "CMM", "CMA"],
  "answer": 2
},
{
  "q": "Hekoru là một dịch vụ dạng",
  "options": [
    "Hạ tầng",
    "Nền tảng",
    "Phần mềm",
    "Tất cả đáp án đều sai"
  ],
  "answer": 0
},
{
  "q": "Viết tắt các bước trong phương pháp đảm bảo bảo mật điện toán đám mây",
  "options": ["PDCA", "DPAC", "PDAC", "Tất cả đáp án đều sai"],
  "answer": 0
},
{
  "q": "Đâu là nhược điểm lớn nhất của điện toán đám mây",
  "options": [
    "Bảo mật",
    "Phụ thuộc nhà cung cấp",
    "Nguyên nhân khác",
    "Tắc nghẽn đường truyền"
  ],
  "answer": 1
},
{
  "q": "Trong các hệ sau đây hệ nào vừa lưu trữ theo văn bản lẫn hệ cột",
  "options": [
    "Tất cả đáp án đều đúng",
    "Hbase",
    "DynamoDB",
    "MongoDB"
  ],
  "answer": 1
},
{
  "q": "Đâu là một nhân tố phụ thuộc trong ảo hóa của điện toán đám mây?",
  "options": [
    "Nhiều ứng dụng cùng chạy trên một server.",
    "Nhiều ổ cứng khác nhau cùng chạy.",
    "Tất cả đáp án đều sai.",
    "Nhiều hệ điều hành cùng chạy trên một một máy chủ vật lý."
  ],
  "answer": 0
},
{
  "q": "Đặc trưng chính của NOSQL là",
  "options": [
    "Tất cả đáp án đều sai",
    "Kết hợp nhiều bảng với nhau thành một bản",
    "Tổ chức mỗi bảng là 1 file dữ liệu",
    "Không tổ chức dữ liệu dưới dạng bảng"
  ],
  "answer": 3
},
{
  "q": "Đâu là ưu điểm của điện toán đám mây?",
  "options": [
    "Tốc độ chấp nhận được.",
    "Tiết kiệm tài nguyên, chi phí",
    "Độ tin cậy tuyệt đối",
    "Tất cả đáp án đều sai"
  ],
  "answer": 1
},
{
  "q": "Đâu là một ưu điểm của mô hình Amazon S3?",
  "options": [
    "Thuật toán truy vấn cực nhanh",
    "Tất cả đáp án đều sai",
    "Độ tin cậy cao",
    "Đội ngũ chuyên gia hỗ trợ nhiều kinh nghiệm"
  ],
  "answer": 2
},
{
  "q": "Đâu là một ưu điểm của mô hình OpenStack Swift?",
  "options": [
    "Đội ngũ chuyên gia hỗ trợ nhiều kinh nghiệm",
    "Tất cả đáp án đều sai",
    "Phân hóa nhiều mức độ",
    "Khả năng tương thích thông qua phần cứng"
  ],
  "answer": 2
},
{
  "q": "Đâu là một nhóm của cách tổ chức NOSQL?",
  "options": [
    "Key/Value",
    "Hướng giá trị số",
    "Cơ sở dữ liệu đồ thị",
    "Tất cả đáp án đều sai"
  ],
  "answer": 2
},
{
  "q": "Đâu là lợi ích của các dịch vụ đám mây?",
  "options": [
    "Tất cả đáp án đều sai",
    "Tự động nhập liệu",
    "Cải tiến quy trình",
    "Phân tán công việc"
  ],
  "answer": 2
},
{
  "q": "Đâu là một nhóm của cách tổ chức NOSQL?",
  "options": [
    "Key/Value",
    "Hướng giá trị số",
    "Hệ cột",
    "Tất cả đáp án đều sai"
  ],
  "answer": 0
},
{
  "q": "RedHat là cung cấp dịch vụ",
  "options": [
    "Phần mềm",
    "Hạ tầng",
    "Nền tảng",
    "Tất cả đáp án đều đúng"
  ],
  "answer": 2
},
{
  "q": "Đâu là một yếu tố của an toàn các dịch vụ IaaS?",
  "options": [
    "Nhiều mạng đụng độ",
    "Kho ảnh máy công cộng",
    "Tất cả đáp án đều sai",
    "Phần cứng không tương thích"
  ],
  "answer": 1
},
{
  "q": "Công nghệ ảo hóa là việc",
  "options": [
    "Kết hợp nhiều máy client thành một máy chung",
    "Tất cả đáp án đều đúng",
    "Kết hợp nhiều mạng thành mạng WAN",
    "Phân chia một máy chủ thành nhiều máy chủ ảo"
  ],
  "answer": 3
},
{
  "q": "Đâu là lỗ hổng liên quan đến ảnh máy ảo?",
  "options": [
    "Được vá lỗi",
    "Tất cả đáp án đều sai",
    "Vị trí lưu trữ xác định",
    "Không thể được vá lỗi"
  ],
  "answer": 3
},
{
  "q": "Đâu là một lỗ hổng liên quan đến dữ liệu?",
  "options": [
    "Dữ liệu lưu trữ không mã hóa",
    "Vị trí lưu trữ xác định",
    "Tất cả đáp án đều sai",
    "Vị trí lưu trữ phân tán"
  ],
  "answer": 0
},
{
  "q": "Đâu là một yếu tố của an toàn các dịch vụ IaaS?",
  "options": [
    "Nhiều người thuê đồng thời",
    "Ảo hóa",
    "Truy cập không đồng thời",
    "Tất cả đáp án đều sai"
  ],
  "answer": 1
},
{
  "q": "Đâu là một đặc điểm của điện toán đám mây?",
  "options": [
    "Truy cập hạn chế",
    "Có khả năng đo lường",
    "Tất cả đáp án đều sai",
    "Thỉnh thoảng có thể mất liên lạc"
  ],
  "answer": 1
},
{
  "q": "Một trung tâm dữ liệu lớn dạng cơ bản có mấy tầng?",
  "options": ["2", "4", "5", "3"],
  "answer": 1
},
{
  "q": "Đâu là lợi ích của SQL Azure?",
  "options": [
    "Tích hợp NOSQL",
    "Chi phí thấp",
    "Tối thiểu dung lượng",
    "Tối đa tính sẵn sàng"
  ],
  "answer": 3
},
{
  "q": "Đâu là một yếu tố của an toàn các dịch vụ IaaS?",
  "options": [
    "Phân cứng không tương thích",
    "Giám sát máy ảo",
    "Truy cập không đồng thời",
    "Tất cả đáp án đều sai"
  ],
  "answer": 1
},
{
  "q": "Đâu là một nhân tố phụ thuộc trong ảo hóa điện toán đám mây?",
  "options": [
    "Tất cả đáp án đều sai",
    "Khả năng sẵn sàng ứng dụng cao",
    "Khả năng cấu hình thấp",
    "Nhiều hệ điều hành cùng chạy trên một máy chủ vật lý"
  ],
  "answer": 1
},
{
  "q": "Amazon thương mại hóa điện toán đám mây năm",
  "options": ["2000", "2006", "2005", "2001"],
  "answer": 1
},
{
  "q": "Đâu là một thành phần của Apps Fabric?",
  "options": [
    "Software config",
    "Access Control",
    "Không có đáp án nào đúng",
    "Dòng lệnh"
  ],
  "answer": 1
},
{
  "q": "Vấn đề nào ít được quan tâm nhất trong công nghệ đám mây?",
  "options": [
    "Công nghệ triển khai",
    "Chi phí vận hành",
    "An toàn bảo mật",
    "Không đủ khả năng điều sai"
  ],
  "answer": 3
},
{
  "q": "Apps Fabric có mấy thành phần chính?",
  "options": ["5", "3", "4", "2"],
  "answer": 3
},
{
  "q": "Đâu là một lỗ hổng của dữ liệu trong mạng ảo?",
  "options": [
    "Mất dữ liệu cho sao chép",
    "Phân tán dữ liệu",
    "Tất cả đáp án đều sai",
    "Dữ liệu không được cập nhật"
  ],
  "answer": 0
},
{
  "q": "Đâu không phải là một đặc điểm của điện toán đám mây?",
  "options": [
    "Tự phục vụ theo yêu cầu",
    "Truy cập rộng rãi",
    "Truy cập không liên tục",
    "Tất cả đáp án đều sai"
  ],
  "answer": 2
},
{
  "q": "MongoDB là NOSQL dạng",
  "options": ["Hướng văn bản", "Key/Value", "Hệ cột", "Đồ thị"],
  "answer": 0
},
{
  "q": "M13 xuất hiện tại khu vực nào của trung tâm dữ liệu lớn?",
  "options": [
    "Phân phối ngang",
    "Tất cả đáp án đều sai",
    "Phân phối thiết bị",
    "Phân phối chính"
  ],
  "answer": 3
},
{
  "q": "Amazon Redshift là NOSQL dạng",
  "options": ["Hướng văn bản", "Key/Value", "Hệ cột", "Đồ thị"],
  "answer": 2
},
{
  "q": "Đâu không phải là nhược điểm của điện toán đám mây?",
  "options": [
    "Tất cả các đáp án đều sai",
    "Độ tin cậy không cao",
    "Phụ thuộc nhà cung cấp",
    "Tiết kiệm"
  ],
  "answer": 3
},
{
  "q": "Neo4j là NOSQL dạng",
  "options": ["Đồ thị", "Hệ cột", "Hướng văn bản", "Key/Value"],
  "answer": 0
},
{
  "q": "Vấn đề nào được quan tâm đứng thứ hai trong công nghệ đám mây?",
  "options": [
    "An toàn và bảo mật",
    "Công nghệ triển khai",
    "Chi phí vận hành",
    "Độ khả dụng"
  ],
  "answer": 3
},
{
  "q": "LAN xuất hiện tại khu vực nào của trung tâm dữ liệu lớn?",
  "options": [
    "Phân phối ngang",
    "Phân phối thiết bị",
    "Các phòng hỗ trợ",
    "Tất cả đáp án đều sai"
  ],
  "answer": 0
},
{
  "q": "Đối với SaaS thì ai là người dùng chủ yếu?",
  "options": [
    "Tester",
    "Người sử dụng phần mềm",
    "Nhà phát triển ứng dụng",
    "Tất cả đáp án đều đúng"
  ],
  "answer": 3
},
{
  "q": "HBase là NOSQL dạng",
  "options": ["Hệ cột", "Key/Value", "Tất cả đáp án đều sai", "Đồ thị"],
  "answer": 0
},
{
  "q": "Chứng nhận SOC phát hành năm",
  "options": ["2012", "2010", "2011", "2015"],
  "answer": 2
},
{
  "q": "Google Drive và OneDrive là một loại dịch vụ",
  "options": ["SaaS", "Tất cả đáp án đều sai", "PaaS", "IaaS"],
  "answer": 0
},
{
  "q": "Dịch vụ nào sau đây là dịch vụ của điện toán đám mây phổ biến?",
  "options": ["Máy chủ online", "Tất cả đáp án đều sai", "Truyền tải file", "Mail"],
  "answer": 0
},
{
  "q": "MISA là một dạng",
  "options": [
    "Hạ tầng hướng dịch vụ",
    "Nền tảng hướng dịch vụ",
    "Phần mềm hướng dịch vụ",
    "Phân tích hướng dịch vụ"
  ],
  "answer": 2
},
{
  "q": "Đâu không phải là yếu tố của an toàn các dịch vụ IaaS?",
  "options": [
    "Phục hồi máy ảo",
    "Giám sát máy ảo",
    "Vòng đời ứng dụng",
    "Tất cả đáp án đều sai"
  ],
  "answer": 2
},
{
  "q": "Google Drive là NOSQL dạng",
  "options": ["Hướng văn bản", "Key/Value", "Hệ cột", "Không phải là NOSQL"],
  "answer": 3
}
],
[
{
  "q": "Xong tài liệu ròi chưa úp vào hehe ! ",
  "options": [""],
  "answer": 3
}
]
    ];
  
    // Trạng thái từng chương
    const chapterStates = chapters.map(chapter => ({
      shuffledQuestions: null,
      answered: null,
      current: 0,
      showingAnswer: false,
      comboStreak: 0,
      comboCounted: null,
      isFinished: false
    }));
  
    let currentChapter = 0;
  
    // Tạo Combo Display NỔI BẬT
    const progressElement = document.getElementById("progress");
    const comboContainer = document.createElement("div");
    comboContainer.style.cssText = `
      margin: 12px 0;
      text-align: center;
      font-family: 'Segoe UI', sans-serif;
    `;
  
    const comboDisplay = document.createElement("div");
    comboDisplay.id = "comboDisplay";
    comboDisplay.style.cssText = `
      display: inline-flex;
      align-items: center;
      gap: 10px;
      padding: 10px 18px;
      border-radius: 50px;
      font-weight: bold;
      font-size: 1.1em;
      box-shadow: 0 4px 15px rgba(0,0,0,0.1);
      transition: all 0.4s cubic-bezier(0.175, 0.885, 0.32, 1.275);
      opacity: 0;
      transform: scale(0.8);
    `;
  
    const fireIcon = document.createElement("span");
    fireIcon.id = "fireIcon";
    fireIcon.innerHTML = "";
    fireIcon.style.fontSize = "1.4em";
  
    const comboText = document.createElement("span");
    comboText.id = "comboText";
  
    comboDisplay.appendChild(fireIcon);
    comboDisplay.appendChild(comboText);
    comboContainer.appendChild(comboDisplay);
    progressElement.parentNode.insertBefore(comboContainer, progressElement.nextSibling);
  
    // CSS Animation cho Combo
    const style = document.createElement('style');
    style.textContent = `
      @keyframes pulseFire {
        0%, 100% { transform: scale(1); }
        50% { transform: scale(1.3); }
      }
      @keyframes bounceIn {
        0% { opacity: 0; transform: scale(0.3); }
        50% { opacity: 1; transform: scale(1.1); }
        100% { transform: scale(1); }
      }
      @keyframes shake {
        0%, 100% { transform: translateX(-50%) translateY(0); }
        10%, 30%, 50%, 70%, 90% { transform: translateX(-50%) translateY(-5px); }
        20%, 40%, 60%, 80% { transform: translateX(-50%) translateY(5px); }
      }
      .combo-level-1 { background: linear-gradient(135deg, #ff6b6b, #ff8e8e); color: white; }
      .combo-level-5 { background: linear-gradient(135deg, #ffd93d, #ffbc00); color: #333; animation: pulseFire 1.5s infinite; }
      .combo-level-10 { background: linear-gradient(135deg, #ff4757, #ff6b7d); color: white; animation: pulseFire 1s infinite; box-shadow: 0 0 20px rgba(255,71,87,0.6); }
    `;
    document.head.appendChild(style);
  
    // Gãy chuỗi thông báo
    const breakStreakElement = document.createElement("div");
    breakStreakElement.id = "breakStreak";
    breakStreakElement.style.cssText = `
      position: fixed; top: 20px; left: 50%; transform: translateX(-50%);
      background: #ff4757; color: white; padding: 14px 28px; border-radius: 16px;
      font-weight: bold; font-size: 1.2em; box-shadow: 0 6px 20px rgba(255,71,87,0.5);
      z-index: 1000; opacity: 0; transition: all 0.5s ease; pointer-events: none;
    `;
    document.body.appendChild(breakStreakElement);
  
    function showBreakStreakMessage() {
      breakStreakElement.textContent = "GÃY CHUỖI! Bạn đã thất bại giữ chuỗi trả lời đúng.";
      breakStreakElement.style.opacity = "1";
      breakStreakElement.style.animation = "shake 0.6s ease";
      setTimeout(() => {
        breakStreakElement.style.opacity = "0";
        breakStreakElement.style.animation = "";
      }, 3000);
    }
  
    function updateComboDisplay() {
      const state = getCurrentState();
      if (state.comboStreak === 0) {
        comboDisplay.style.opacity = "0";
        comboDisplay.style.transform = "scale(0.8)";
        return;
      }
  
      // Cập nhật nội dung
      const fireCount = Math.min(state.comboStreak, 15);
      fireIcon.innerHTML = " ".repeat(fireCount);
      comboText.textContent = `Combo: ${state.comboStreak} liên tiếp!`;
  
      // Cập nhật lớp màu
      comboDisplay.className = "";
      if (state.comboStreak >= 10) {
        comboDisplay.classList.add("combo-level-10");
      } else if (state.comboStreak >= 5) {
        comboDisplay.classList.add("combo-level-5");
      } else {
        comboDisplay.classList.add("combo-level-1");
      }
  
      // Hiệu ứng xuất hiện
      comboDisplay.style.opacity = "1";
      comboDisplay.style.transform = "scale(1)";
      comboDisplay.style.animation = "bounceIn 0.5s ease";
    }
  
    function shuffleArray(array) {
      const arr = [...array];
      for (let i = arr.length - 1; i > 0; i--) {
        const j = Math.floor(Math.random() * (i + 1));
        [arr[i], arr[j]] = [arr[j], arr[i]];
      }
      return arr;
    }
  
    function getCurrentState() {
      return chapterStates[currentChapter];
    }
  
    function updateProgress() {
      const state = getCurrentState();
      document.getElementById("progress").textContent =
        `Chương ${currentChapter + 1} - Câu ${state.current + 1}/${state.shuffledQuestions.length} - Còn lại ${state.shuffledQuestions.length - state.current - 1} câu`;
      updateComboDisplay();
    }
  
    function updateQuestionGrid() {
      const state = getCurrentState();
      const grid = document.getElementById("questionGrid");
      let html = "";
      state.shuffledQuestions.forEach((_, i) => {
        const isAnswered = state.answered[i] !== null;
        const isCurrent = i === state.current;
        html += `<div class="grid-item ${isAnswered ? 'answered' : ''} ${isCurrent ? 'current' : ''}" data-index="${i}">${i + 1}</div>`;
      });
      grid.innerHTML = html;
  
      document.querySelectorAll(".grid-item").forEach(item => {
        item.addEventListener("click", () => {
          state.current = parseInt(item.getAttribute("data-index"));
          state.showingAnswer = false;
          loadQuestion();
        });
      });
    }
  
    function loadQuestion() {
      const state = getCurrentState();
      const qBox = document.getElementById("quiz");
      const q = state.shuffledQuestions[state.current];
      let html = `<div class="question">${q.q}</div><div class="options">`;
      q.options.forEach((opt, i) => {
        const checked = state.answered[state.current] === i ? "checked" : "";
        html += `
          <label>
            <input type="radio" name="opt" value="${i}" ${checked}>
            <span>${opt}</span>
          </label>`;
      });
      html += "</div><div id='answerBox'></div>";
      qBox.innerHTML = html;
  
      document.getElementById("prevBtn").disabled = state.current === 0;
      document.getElementById("nextBtn").innerText = state.current === state.shuffledQuestions.length - 1 ? "Kết thúc" : "Tiếp theo";
  
      document.querySelectorAll('input[name="opt"]').forEach(input => {
        input.addEventListener("change", e => {
          state.answered[state.current] = parseInt(e.target.value);
          updateQuestionGrid();
        });
      });
  
      updateProgress();
      updateQuestionGrid();
      state.showingAnswer = false;
    }
  
    function switchChapter(chapterIndex) {
      const prevState = getCurrentState();
      currentChapter = chapterIndex;
  
      if (prevState.isFinished) {
        restoreQuizInterface();
      }
  
      if (!chapterStates[currentChapter].shuffledQuestions) {
        chapterStates[currentChapter].shuffledQuestions = shuffleArray(chapters[currentChapter]);
        chapterStates[currentChapter].answered = Array(chapterStates[currentChapter].shuffledQuestions.length).fill(null);
        chapterStates[currentChapter].comboCounted = Array(chapterStates[currentChapter].shuffledQuestions.length).fill(false);
        chapterStates[currentChapter].current = 0;
        chapterStates[currentChapter].comboStreak = 0;
        chapterStates[currentChapter].isFinished = false;
      }
  
      document.querySelectorAll(".tab").forEach(tab => tab.classList.remove("active"));
      document.querySelector(`.tab[data-chapter="${chapterIndex}"]`).classList.add("active");
  
      loadQuestion();
    }
  
    function restoreQuizInterface() {
      document.querySelector(".quiz-container").innerHTML = `
        <div class="logo">
          <img src="asset/img/dnc.jpg" alt="Logo">
        </div>
        <div class="title">Trắc nghiệm ôn thi</div>
        <div id="progress"></div>
        <div id="combo"></div>
        <div id="quiz"></div>
        <div class="controls">
          <button id="prevBtn">Quay lại</button>
          <button id="nextBtn">Tiếp theo</button>
        </div>
      `;
  
      const newProgress = document.getElementById("progress");
      newProgress.parentNode.insertBefore(comboContainer, newProgress.nextSibling);
  
      document.getElementById("prevBtn").addEventListener("click", () => {
        const state = getCurrentState();
        if (state.current > 0) {
          state.current--;
          loadQuestion();
        }
      });
  
      document.getElementById("nextBtn").addEventListener("click", () => {
        const state = getCurrentState();
        if (!state.showingAnswer) {
          const q = state.shuffledQuestions[state.current];
          const userAns = state.answered[state.current];
          let ansHtml = `
            <div class="answer-box">
              <div>
                <span class="icon">${userAns === q.answer ? "Correct" : "Wrong"}</span>
                Bạn chọn: <span class="${userAns === q.answer ? 'correct' : 'wrong'}">
                  ${userAns !== null ? q.options[userAns] : "(không chọn)"}
                </span>
              </div>
              <div>
                <span class="icon">Correct</span>
                Đáp án đúng: <span class="correct">${q.options[q.answer]}</span>
              </div>
            </div>
          `;
          document.getElementById("answerBox").innerHTML = ansHtml;
          state.showingAnswer = true;
  
          if (userAns === q.answer && userAns !== null && !state.comboCounted[state.current]) {
            state.comboStreak++;
            state.comboCounted[state.current] = true;
          } else if (userAns !== q.answer || userAns === null) {
            if (state.comboStreak > 0) showBreakStreakMessage();
            state.comboStreak = 0;
            state.comboCounted.fill(false);
          }
          updateComboDisplay();
          return;
        }
        if (state.current < state.shuffledQuestions.length - 1) {
          state.current++;
          loadQuestion();
        } else {
          showSummary();
        }
      });
    }
  
    switchChapter(0);
  
    document.querySelectorAll(".tab").forEach(tab => {
      tab.addEventListener("click", () => {
        const chapterIndex = parseInt(tab.getAttribute("data-chapter"));
        if (chapterIndex !== currentChapter) switchChapter(chapterIndex);
      });
    });
  
    document.getElementById("nextBtn").addEventListener("click", () => {
      const state = getCurrentState();
      if (!state.showingAnswer) {
        const q = state.shuffledQuestions[state.current];
        const userAns = state.answered[state.current];
  
        let ansHtml = `
          <div class="answer-box">
            <div>
              <span class="icon">${userAns === q.answer ? "Correct" : "Wrong"}</span>
              Bạn chọn: <span class="${userAns === q.answer ? 'correct' : 'wrong'}">
                ${userAns !== null ? q.options[userAns] : "(không chọn)"}
              </span>
            </div>
            <div>
              <span class="icon">Correct</span>
              Đáp án đúng: <span class="correct">${q.options[q.answer]}</span>
            </div>
          </div>
        `;
        document.getElementById("answerBox").innerHTML = ansHtml;
        state.showingAnswer = true;
  
        if (userAns === q.answer && userAns !== null && !state.comboCounted[state.current]) {
          state.comboStreak++;
          state.comboCounted[state.current] = true;
        } else if (userAns !== q.answer || userAns === null) {
          if (state.comboStreak > 0) showBreakStreakMessage();
          state.comboStreak = 0;
          state.comboCounted.fill(false);
        }
        updateComboDisplay();
        return;
      }
  
      if (state.current < state.shuffledQuestions.length - 1) {
        state.current++;
        loadQuestion();
      } else {
        showSummary();
      }
    });
  
    document.getElementById("prevBtn").addEventListener("click", () => {
      const state = getCurrentState();
      if (state.current > 0) {
        state.current--;
        loadQuestion();
      }
    });
  
    function showSummary() {
      const state = getCurrentState();
      const correct = state.answered.filter((a, i) => a === state.shuffledQuestions[i].answer).length;
  
      const comboHighlight = state.comboStreak > 0 
        ? `<div style="
            font-size: 1.6em; 
            font-weight: bold; 
            color: #ff4757; 
            text-align: center; 
            margin: 20px 0; 
            animation: pulseFire 1.5s infinite;
            text-shadow: 0 0 15px rgba(255,71,87,0.5);
          ">
            Combo cao nhất: ${state.comboStreak} liên tiếp!
          </div>`
        : `<div style="font-size: 1.2em; color: #aaa; text-align: center; margin: 15px 0;">
            Chưa có combo nào!
          </div>`;
  
      let reviewHtml = `
        <div class="summary">Bạn trả lời đúng ${correct}/${state.shuffledQuestions.length} câu!</div>
        ${comboHighlight}
        <div class="review">`;
      state.shuffledQuestions.forEach((q, i) => {
        const userAns = state.answered[i];
        const isCorrect = userAns === q.answer;
        reviewHtml += `
          <div class="answer-block">
            <div class="question">${q.q}</div>
            <div>Bạn chọn: <span class="${isCorrect ? 'correct' : 'wrong'}">${userAns !== null ? q.options[userAns] : "(không chọn)"}</span></div>
            <div>Đáp án đúng: <span class="correct">${q.options[q.answer]}</span></div>
          </div>
        `;
      });
      reviewHtml += `
        </div>
        <div style="text-align:center; margin-top:20px;">
          <button id="restartChapterBtn" style="padding:12px 24px; font-size:1.1em; border-radius:30px; background:#007bff; color:white; border:none; cursor:pointer;">Làm lại chương này</button>
        </div>
      `;
      document.querySelector(".quiz-container").innerHTML = reviewHtml;
  
      state.isFinished = true;
  
      document.getElementById("restartChapterBtn").addEventListener("click", () => {
        chapterStates[currentChapter].shuffledQuestions = shuffleArray([...chapters[currentChapter]]);
        chapterStates[currentChapter].answered = Array(chapterStates[currentChapter].shuffledQuestions.length).fill(null);
        chapterStates[currentChapter].comboCounted = Array(chapterStates[currentChapter].shuffledQuestions.length).fill(false);
        chapterStates[currentChapter].current = 0;
        chapterStates[currentChapter].showingAnswer = false;
        chapterStates[currentChapter].comboStreak = 0;
        chapterStates[currentChapter].isFinished = false;
  
        restoreQuizInterface();
        loadQuestion();
      });
    }
  
    // Khóa DevTools
    (function lockDevTools() {
      document.addEventListener('contextmenu', e => e.preventDefault());
      document.addEventListener('selectstart', e => e.preventDefault());
      document.addEventListener('copy', e => e.preventDefault());
      document.addEventListener('keydown', e => {
        const key = e.key || e.keyCode;
        if (e.key === 'F12' || key === 123 || (e.ctrlKey && e.shiftKey && ['I','J','C'].includes(e.key)) || (e.ctrlKey && ['U','u','S','s'].includes(e.key))) {
          e.preventDefault(); e.stopPropagation(); return false;
        }
      });
      let devtoolsOpen = false;
      const threshold = 160;
      setInterval(() => {
        const open = (window.outerWidth - window.innerWidth > threshold) || (window.outerHeight - window.innerHeight > threshold);
        if (open && !devtoolsOpen) {
          devtoolsOpen = true;
          console.clear();
          console.log("DevTools detected - nội dung bị hạn chế.");
        } else if (!open) devtoolsOpen = false;
      }, 1000);
    })();
  </script>
</body>
</html>