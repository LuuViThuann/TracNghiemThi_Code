<!DOCTYPE html>
<html lang="vi">
<head>
  <link rel="icon" href="/asset/img/tom.svg" type="image/png">
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>TOM - IT</title>
  <link rel="stylesheet" href="asset/css/style.css">
</head>
<body>
  <div class="container">
    <div class="tabs">
      <button class="tab active" data-chapter="0">THIẾT KẾ PHẦN MỀM</button>
      <button class="tab" data-chapter="1">ĐIỆN TOÁN ĐÁM MÂY</button>
      <button class="tab" data-chapter="2">LẬP TRÌNH DI ĐỘNG</button>
      
    
    </div>

    <div class="container-all">
      <div class="quiz-container">
        <div class="logo">
          <img src="asset/img/dnc.jpg" alt="Logo">
        </div>
        <div class="title">Trắc nghiệm ôn thi</div>
        <div id="progress"></div>
        <div id="quiz"></div>
        <div class="controls">
          <button id="prevBtn">⏪ Quay lại</button>
          <button id="nextBtn">⏭ Tiếp theo</button>
        </div>
      </div>
      <div class="grid-container">
        <div class="question-grid" id="questionGrid"></div>
      </div>
    </div>
   
  </div>
  <script>
    const chapters = [
     [
     {
  "q": "Xin chào và tạm bịt  ! ",
  "options": [""],
  "answer": 3
}
     ],
  
      // ĐIỆN TOÁN ĐÁM MÂY
      [
   
      {
  "q": "Xin chào và tạm bịt  ! ",
  "options": [""],
  "answer": 3
}

],
[
{
    "q": "Hiện nay có bao nhiêu cách để phát triển ứng dụng cho thiết bị di động? Cách nào là cơ bản nhất mà người phát triển ứng dụng cho thiết bị di động phải học trước tiên?",
    "options": [
      "Có 4 cách để phát triển ứng dụng cho thiết bị di động. Cách phát triển ứng dụng trên nền tảng chéo (Cross platform) là cơ bản nhất.",
      "Có 5 cách để phát triển ứng dụng cho thiết bị di động. Cách phát triển ứng dụng trên nền tảng gốc (Native platform) là cơ bản nhất.",
      "Có 5 cách để phát triển ứng dụng cho thiết bị di động. Cách phát triển ứng dụng kiểu lập trình nhúng là cơ bản nhất.",
      "Có 4 cách để phát triển ứng dụng cho thiết bị di động. Cách phát triển ứng dụng lai (Hydrid Apps) là cơ bản nhất."
    ],
    "answer": 1
  },
  {
    "q": "Khái niệm trừu tượng (abstraction) trong lập trình gồm những thành phần như:",
    "options": [
      "Những môi trường phát triển phần mềm (SDE).",
      "Là những phần mềm nằm giữa phần cứng và môi trường phát triển ứng dụng như: menu, database, file systems, related runtime libraries,API,…",
      "Máy ảo (Emulator).",
      "Là lớp (class) không thể được dùng để tạo ra các đối tượng như những lớp bình thường khác."
    ],
    "answer": 1
  },
  {
    "q": "IDE (integrated design environment hay integrated debugging environment) là:",
    "options": [
      "Một hệ điều hành hay một máy ảo(virtual machine) trên đỉnh của phần cứng, nó cho khả năng viết code một lần để phát triển ứng dụng chạy trên nhiều nền tảng.",
      "Một tổng thể(gồm cả phần cứng lẫn phần mềm)mà nó cung cấp toàn bộ các phương tiện để người lập trình máy tính phát triển phần mềm ứng dụng.",
      "Một phần mềm ứng dụng mà nó cung cấp toàn bộ các phương tiện để người lập trình máy tính phát triển phần mềm ứng dụng trên một hoặc nhiều nền tảng.",
      "Một môi trường lập trình hỗ trợ nhiều ngôn ngữ lập trình khác nhau để lập trình phát triển ứng dụng, sau đó biên dịch sang một ngôn ngữ trung gian (bytecode) và ứng dụng chỉ chạy trên một hệ điều hành."
    ],
    "answer": 2
  },
  {
    "q": "Kiến trúc Thin-Client Wireless Client-Server là:",
    "options": [
      "Kiến trúc mà khi client truyền thông với server, nó có thể thực thi vài việc và server thực hiện các việc khác. Vì vậy không cần kết nối mạng liên tục và ổn định.",
      "Kiến trúc mà ứng dụng được thực hiện bởi server. Vì vậy đòi hỏi client phải kết nối mạng liên tục và ổn định với server, tương ứng với tập các đặc tính kỹ thuật chung nhỏ nhất của các thiết bị và platform.",
      "Kiến trúc truyền thông theo giao thức TCP/IP.",
      "Kiến trúc truyền thông theo giao thức UDP."
    ],
    "answer": 1
  },
  {
    "q": "Ứng dụng lai (Hybrid application) là ứng dụng như thế nào?",
    "options": [
      "Là ứng dụng chỉ cần lập trình một lần trên một môi trường và có thể chạy trên nhiều nền tảng khác nhau.",
      "Là ứng dụng có thể chạy đồng thời trên máy tính PC, trên Smart phone và Tablet.",
      "Là ứng dụng thể chạy đồng thời trên máy tính PC, trên Smart phone, Tablet và Mobile web.",
      "Là ứng dụng cho thiết bị di động chạy trên nền web, được lập trình trên một môi trường phát triển chạy trên các thiết bị di động với các nền tảng khác nhau."
    ],
    "answer": 2
  },
  {
    "q": "Quá trình phát triển của mạng viễn thông di động trải qua các thế hệ 1G, 2G, 3G, 4G, 5G. Sự chuyển đổi từ kỹ thuật tương tự (analog) sang kỹ thuật số (digital) diễn ra trong thế hệ nào?",
    "options": [
      "2G",
      "3G",
      "4G",
      "Áp dụng kỹ thuật số ngay từ đầu."
    ],
    "answer": 0
  },
  {
    "q": "Phân biệt mạng Piconet và Scatternet trong kỹ thuật Bluetooth",
    "options": [
      "Scatternet là mạng liên kết các thiết bị cùng cấp, Piconet là mạng liên kết giữa các Scatternet.",
      "Piconet là mạng liên kết các thiết bị cùng cấp, Scatternet là mạng liên kết giữa các Piconet.",
      "Piconet là mạng liên kết các thiết bị cùng loại, Scatternet là mạng liên kết giữa các thiết bị khác loại.",
      "Piconet là mạng liên kết các thiết bị khác loại, Scatternet là mạng liên kết giữa các thiết bị cùng loại."
    ],
    "answer": 1
  },
  {
    "q": "Điện thoại Android đầu tiên tên gì? Ra mắt năm nào?",
    "options": [
      "T-Mobile G1 – 1, 2007",
      "Nexus – one, 2008",
      "T-Mobile G1 – 1, 2008",
      "HTC One, 2008"
    ],
    "answer": 2
  },
  {
    "q": "Mỗi phiên bản của hệ điều hành Android có 3 tên đại diện là gì? Cho biết các tên này ứng với phiên bản mới nhất hiện nay (tính đến tháng 08/2023)?",
    "options": [
      "3 tên đại diện cho phiên bản là: Release number,Target name và API level. Tương ứng với phiên bản mới nhật hiện nay là Release number = 14, Target name = S và API level = 34.",
      "3 tên đại diện cho phiên bản là:Version number,Target name và API. Tương ứng với phiên bản mới nhật hiện nay là Version number = 12.0,Target name = S và API = 31.",
      "3 tên đại diện cho phiên bản là: Target,Version name và API level. Tương ứng với phiên bản mới nhật hiện nay là Target = 12L, Release name = Sv2 và API level = 32.",
      "3 tên đại diện cho phiên bản là: Target, Release name và API level. Tương ứng với phiên bản mới nhật hiện nay là Target = 13, Release name = Tiramisu và API level = 33."
    ],
    "answer": 3
  },
  {
    "q": "Kiến trúc của hệ điều hành Android bao gồm các tầng như sau:",
    "options": [
      "Linux Kernel; Library - Android runtime; Application Framework; Applications.",
      "Linux Kernel; Library; Android runtime; Application Framework; Applications.",
      "Unix Kernel; Library; Android runtime; Applications.",
      "Linux Kernel; Application Framework; Virtual machine; Applications."
    ],
    "answer": 0
  },
  {
    "q": "Một trong các ưu điểm của nền tảng Android là tính năng mở, tính năng mở có nghĩa là:",
    "options": [
      "Mã nguồn mở.",
      "Không tốn phí cho môi trường phát triển ứng dụng.",
      "Có thể chạy thử phần mềm trực tiếp trên máy thật trong khi lập trình phát triển.",
      "Tất cả các câu trả lời đều đúng."
    ],
    "answer": 3
  },
  {
    "q": "Trong 6 thành phần của ứng dụng Android có 4 thành phần chính cấu thành ứng dụng là:",
    "options": [
      "Activity, Service, Broadcast Receiver và Content Provider là 4 thành phần chính cấu thành nên ứng dụng Android, cần khai báo trong AndroidManifest.",
      "Activity, Service, Broadcast Receiver và Intent là 4 thành phần chính cấu thành nên ứng dụng Android, cần khai báo trong AndroidManifest.",
      "Activity, Service, Intent và Content Provider là 4 thành phần chính cấu thành nên ứng dụng Android, cần khai báo trong AndroidManifest.",
      "Activity, Intent, Broadcast Receiver và Content Provider là 4 thành phần chính cấu thành nên ứng dụng Android, cần khai báo trong AndroidManifest."
    ],
    "answer": 0
  },
  {
    "q": "Activity là thành phần trong một ứng dụng Android:",
    "options": [
      "Trong mỗi ứng dụng đều phải có Activity.",
      "Mỗi Activity tương ứng với một giao diện người dùng.",
      "Một ứng dụng có thể có một hoặc nhiều Activity.",
      "Tất cả các câu trả lời đúng."
    ],
    "answer": 3
  },
  {
    "q": "Khi mở project mới ta cần khai báo chọn bao nhiêu phiên bản, những phiên bản nào? Tại sao?",
    "options": [
      "Cần khai báo 3 phiên bản: 1 để biên dịch (mới nhất, mặc định), 1 phiên bản cũ nhất có thể chạy được ứng dụng và 1 phiên bản trung gian để chạy thử ứng dụng.",
      "Cần khai báo từ 3 phiên bản trở lên: 1 để biên dịch (mới nhất), 1 phiên bản cũ nhất có thể chạy được ứng dụng và các phiên bản trung gian để chạy thử ứng dụng bằng máy ảo.",
      "Cần khai báo 2 phiên bản: 1 để biên dịch (mới nhất, mặc định), 1 phiên bản cũ nhất có thể chạy được ứng dụng.",
      "Cần khai báo 1 phiên bản mới nhất (mặc định)."
    ],
    "answer": 2
  },
  {
    "q": "Explicit Intents là:",
    "options": [
      "Intent được chỉ xác định hành động cần thực hiện khi không chỉ định thành phần cần gọi để xử lý.",
      "Intent cần khai báo rõ các thuộc tính action, data.",
      "Intent thường được sử dụng để khởi chạy các ứng dụng đã được cài đặt trên thiết bị.",
      "Intent đã được xác định thuộc tính component, nghĩa là đã chỉ rõ thành phần sẽ nhận và xử lý. Explicit Intent thường được sử dụng để khởi chạy các activity trong cùng một ứng dụng."
    ],
    "answer": 3
  },
  {
    "q": "Lập trình giao diện người dùng mức cao là:",
    "options": [
      "Cách tạo giao diện người dùng tùy biến bằng các đối tượng do người lập trình tạo ra.",
      "Cách lập trình xây dựng giao diện người dùng sử dụng các kiểu giao diện được định nghĩa (Layout) và các đối tượng có sẵn (View) trong Android SDK.",
      "Cách lập trình sử dụng công cụ kéo thả trong Android Studio.",
      "Cách lập trình viết cách viết code mà không dùng công cụ kéo thả trong Android Studio."
    ],
    "answer": 1
  },
  {
    "q": "Khi sử dụng LinearLayout cần phải khai báo thêm thuộc tính gì?",
    "options": [
      "Thuộc tính android:orientation.",
      "Thuộc tính android:layout_gravity.",
      "Không bắt buộc khai báo thêm.",
      "Thuộc tính android:layout_width và android:layout_height."
    ],
    "answer": 0
  },
  {
    "q": "Trong Android, để Activity (giả sử viết bằng ngôn ngữ Java) hiển thị một giao diện ta sử dụng phương thức và câu lệnh như sau (Giả sử “giaodien” là tên giao diện được chọn để hiển thị):",
    "options": [
      "setLayoutView(R.layout.giaodien);",
      "setIntentView(R.layout.giaodien);",
      "setContentView(R.layout.giaodien);",
      "setContentLayout(R.layout.giaodien);"
    ],
    "answer": 2
  },
  {
    "q": "Để sử dụng đối tượng ImageView ta phải lưu tên tập tin của ảnh muốn hiển thị vào đâu và câu lệnh bắt buộc (không mặc định) trong mã nguồn xml là gì?",
    "options": [
      "Lưu ảnh vào thư mục res/drawable và câu lệnh xml bắt buộc phải khai báo là android:src=”@drawable/”tên tập tin ảnh”.",
      "Lưu ảnh vào thư mục res/layout và câu lệnh xml bắt buộc phải khai báo là android:contentDescription=”@drawable/”tên tập tin ảnh”.",
      "Lưu ảnh vào thư mục res/mipmap và câu lệnh xml bắt buộc phải khai báo là android:src=”@drawable/”tên tập tin ảnh”.",
      "Tất cả A, B và C đều sai."
    ],
    "answer": 0
  },
  {
    "q": "Cách ánh xạ một View trong tập tin Layout.xml vào mã nguồn Java của Activity tương ứng? Cho ví dụ.",
    "options": [
      "Dùng phương thức setContentView(R.id.tên định danh của View); ...",
      "Dùng phương thức findViewById(R.id.tên định danh của View); ...",
      "Dùng phương thức getViewById(R.layout.R.layout.tên định danh của View); ...",
      "Tất cả A, B và C đều sai."
    ],
    "answer": 1
  },
  {
    "q": "Bằng cách gom nhóm các RadioButton vào một RadioGroup cho phép:",
    "options": [
      "Có thể check nhiều RadioButton trong cùng một nhóm.",
      "Chỉ được check chọn một RadioButton trong cùng một nhóm.",
      "Khi check một RadioButton thì tất cả các RadioButton trong cùng nhóm đều được check.",
      "Tuỳ thuộc vào giá trị của thuộc tính check được khai báo trong tập tin layout..."
    ],
    "answer": 1
  },
  {
    "q": "Người lập trình phát triển ứng dụng có thể kết hợp giao diện mức cao và mức thấp bằng cách nào?",
    "options": [
      "Trong giao diện mức cao ta có thể lồng vào giao diện mức thấp.",
      "Trong giao diện mức thấp ta có thể lồng vào giao diện mức cao.",
      "Từ Activity có giao diện mức thấp gọi Activity có giao diện mức cao hoặc ngược lại.",
      "Tất cả các câu trả lời đều đúng."
    ],
    "answer": 3
  },
  {
    "q": "Các bước lập trình xử lý tương tác của người dùng lên các View như sau:",
    "options": [
      "Khai báo View trong Layout → Ánh xạ View này vào Activity tương ứng bằng phương thức findViewById(R.id.<tên định danh của View>) → Sử dụng phương thức setOnClickListener() kết hợp với onClick().",
      "Khai báo View trong Layout → Tạo phương thức xử lý tương tác... → Khai báo thuộc tính onClick cho View trong tập tin Layout như sau: android:onClick=”ptTuongtac”.",
      "Các câu trả lời A và B đều đúng.",
      "Câu trả lời A đúng và câu trả lời B sai."
    ],
    "answer": 2
  },
  {
    "q": "Menu rất hữu ích để hiển thị tùy chọn bổ sung mà không trực tiếp nhìn thấy trên giao diện của một Activity. Trong đó, Context Menu có chức năng và đặc điểm là:",
    "options": [
      "Hiển thị những thông tin liên quan đến Activity hiện tại. Menu này thường nằm ở góc phải phía trên của giao diện...",
      "Hiển thị những thông tin liên quan đến một đối tượng View cụ thể, để kích hoạt menu này người dùng cần nhấn và giữ đối tượng View mà nó liên kết.",
      "Hiển thị những thông tin liên quan đến một đối tượng View cụ thể, để kích hoạt menu này người dùng chỉ cần nhấn vào đối tượng View mà nó liên kết.",
      "Hiển thị những thông tin liên quan đến ứng dụng..."
    ],
    "answer": 1
  },
  {
    "q": "Các bước để thực hiện một Intent ngầm (Implicit Intent) gồm:",
    "options": [
      "Bước 1: Định nghĩa dữ liệu kèm theo dưới dạng Uri; Bước 2: Khai báo một Intent với 1 Action cụ thể và Uri đã định nghĩa; Bước 3: Gọi hàm startActivity() hoặc startActivityForResult()...",
      "Bước 1: Khai báo một Intent với 1 Action cụ thể; Bước 2: Gọi hàm startActivity()...; Bước 3: Khai báo View cần thiết...",
      "Bước 1: Khai báo View cần thiết...; Bước 2: Khai báo một Intent...; Bước 3: Gọi hàm startActivity()...",
      "Bước 1: Khai báo một Intent với 1 Action cụ thể; Bước 2: Định nghĩa dữ liệu kèm theo dưới dạng Bundle; Bước 3: Gọi hàm startActivity()..."
    ],
    "answer": 0
  },
  {
    "q": "Trong thiết bị di động, bộ nhớ trong và bộ nhớ ngoài được phân biệt như sau:",
    "options": [
      "Bộ nhớ trong là bộ nhớ RAM, bộ nhớ ngoài là bộ nhớ ROM.",
      "Bộ nhớ trong là bộ nhớ được gắn sẵn trong thiết bị, bộ nhớ ngoài là SDCard.",
      "Bộ nhớ trong gồm RAM và bộ nhớ được gắn sẵn trong thiết bị, bộ nhớ ngoài là SDCard.",
      "Bộ nhớ trong chỉ được dùng để lưu dữ liệu riêng của mỗi ứng dụng, bộ nhớ ngoài dùng để lưu dữ liệu dùng chung..."
    ],
    "answer": 1
  },
  {
    "q": "Đối tượng Preferences thường dùng để lưu trữ, điều chỉnh và phục hồi nội dung gì?",
    "options": [
      "Tập các tính năng của ứng dụng được người dùng tuỳ chọn.",
      "Các thiết lập của người dùng trong một ứng dụng.",
      "Tập các hoạt động của ứng dụng được người dùng tuỳ chọn.",
      "Tất cả A, B, C đều đúng."
    ],
    "answer": 3
  },
  {
    "q": "Các đối tượng được dùng để xây dựng thiết lập trong Android gồm:",
    "options": [
      "ListboxPreference; ViewPreference; FramePreference.",
      "CheckBoxPreference; ListPreference; EditTextPreference.",
      "PreferenceFragment; PreferenceActivity.",
      "Tất cả A, B và C đều sai."
    ],
    "answer": 1
  },
  {
    "q": "Tạo bảng: tên là Lop_CT274, gồm 7 cột: ID, MSSV, Họ_Tên, Email, Diem_KT, Điểm_Thi, Điểm_TH. Hãy viết chuỗi tạo bảng.",
    "options": [
      "String CreatetbSchool=\"create table Lop_CT274 (+”id integer primary key autoincrement”,+”MSSV” text, ...",
      "String CreatetbSchool=\"create table Lop_CT274 (\"+\"id integer primary key autoincrement,\"+“MSSV text, \"+“Ho_Ten text, \"+“Email text, \"+“Diem_KT float, \"+“Diem_Thi float, \"+“Diem_TH float)\");",
      "String CreatetbSchool=\"table Lop_CT274 (\"+\"id integer key autoincrement,\"+...",
      "Các câu khác với câu này đều sai."
    ],
    "answer": 1
  },
  {
    "q": "Để thao tác với cơ sở dữ liệu SQLite trên Android ta sử dụng các đối tượng nào?",
    "options": [
      "SQLiteOpenController và SQLiteDatabase.",
      "SQLiteOpenHelper và SQLiteDatabase.",
      "SQLiteData và SQLiteOpenManager.",
      "SQLiteOpenHelper và SQLiteDataContent"
    ],
    "answer": 1
  },
  {
    "q": "Trong Android có nhiều Content Provider hữu dụng được dựng sẵn như CallLog, Contacts, MediaStore, Settings. Để truy vấn một Content Provider, chẳng hạn như lấy tất cả các contacts từ một Contacts content provider, chúng ta khai báo URI như sau:",
    "options": [
      "contentprovider://contacts/people",
      "provider://contacts/people",
      "content://contacts/people",
      "provider://content/contacts/people"
    ],
    "answer": 2
  },
  {
    "q": "Để xóa bảng trong cơ sở dữ liệu SQLite, giả sử có tên là db, ta áp dụng phương thức:",
    "options": [
      "db.deleteDatabase(<tên Bảng>)",
      "db.execSQL(“Chuỗi xóa bảng”)",
      "db.delete(“Tên bảng”)",
      "db.deleteTable(<tên Bảng>)"
    ],
    "answer": 1
  },
  {
    "q": "Để tạo ra một đối tượng con trỏ dùng để đọc tin nhắn trong thư mục inbox ta dùng phương thức nào? Cú pháp?",
    "options": [
      "Dùng phương thức getSmsContent và phương thức query...",
      "Dùng phương thức getContent và phương thức query...",
      "Dùng phương thức getContent và phương thức getquery...",
      "Dùng phương thức getContentResolver và phương thức query, với cú pháp như sau: Cursor c = getContentResolver().query(SMS_INBOX, null, null, null, null);"
    ],
    "answer": 3
  },
  {
    "q": "Yêu cầu GET trong giao thức HTTP có đặc điểm gì?",
    "options": [
      "Yêu cầu thông tin - dữ liệu được chuyển đi như là một phần của URL, được dùng để lấy dữ liệu từ server và đây là phương thức mặc định.",
      "Yêu cầu thông tin - dữ liệu được chuyển đi trong luồng riêng biệt, dùng để gởi dữ liệu đến server.",
      "Yêu cầu thông tin - dữ liệu được chuyển đi như là một phần của URL, được dùng để gởi dữ liệu đến server và đây là phương thức mặc định.",
      "Yêu cầu thông tin - dữ liệu được chuyển đi với 2 phần riêng biệt gồm URL và dữ liệu trong cùng một luồng..."
    ],
    "answer": 0
  },
  {
    "q": "Để có thể thực hiện các cuộc giao tiếp, một trong hai quá trình phải công bố số hiệu cổng của socket mà mình sử dụng. Ngoài số hiệu cổng, hai bên giao tiếp còn phải biết địa chỉ IP của nhau. Cho biết vai trò của số hiệu cổng và địa chỉ IP.",
    "options": [
      "Số hiệu cổng và IP là một cặp để xác định server hoặc client.",
      "Địa chỉ IP giúp phân biệt các thiết bị trên mạng TCP/IP. Trong khi số hiệu cổng dùng để phân biệt các quá trình khác nhau trên cùng một máy tính.",
      "Cổng đề xác định đường truyền, địa chỉ IP để xác định thiết bị trên mạng TCP/IP.",
      "Số hiệu cổng và địa chỉ IP đều bắt buộc khai báo trong mọi trường hợp cho cả client và server."
    ],
    "answer": 1
  },
  {
    "q": "Hoạt động mạng là yêu cầu cơ bản và đã được thiết kế sẵn cho hầu hết các thiết bị di động. Như vậy, trong trường hợp nào người lập trình phát triển ứng dụng di động cần phải lập trình kết nối mạng cho thiết bị di động?",
    "options": [
      "Khi xây dựng một ứng dụng có các chức năng cần phải kết nối mạng, người phát triển phần mềm cần lập trình mạng cho ứng dụng của mình.",
      "Nguyên tắc chung cho các ứng dụng di động là phải có kết nối mạng, nên người lập trình phát triển ứng dụng di động luôn luôn phải thực hiện nội dung này trong các ứng dụng của mình.",
      "Vì các hoạt động mạng đã được thiết kế sẵn trên tất cả các thiết bị di động, nên người lập trình ứng dụng di động không cần lập trình kết nối mạng.",
      "Người lập trình phát triển ứng dụng di động luôn luôn phải thực hiện nội dung này trong khi lập trình..."
    ],
    "answer": 0
  },
  {
    "q": "Lớp nào được sử dụng để mở 1 kết nối http với URL từ xa? Cú pháp?",
    "options": [
      "Có thể dùng lớp HttpConnection và hàm getConnection()...",
      "Có thể dùng lớp URLConnection và hàm openConnection(), cú pháp: URL url=new URL(urlString); URLConnection conn=url.openConnection();",
      "Có thể dùng lớp ConnectionUrl và hàm urlConnection()...",
      "Tất cả A, B và C đều sai."
    ],
    "answer": 1
  },
  {
    "q": "Cấu trúc ngôn ngữ JSON?",
    "options": [
      "Thông điệp JSON được chia thành các đối tượng(JSONObject). Mỗi đối tượng được bắt đầu và kết thúc bằng một cặp ngoặc quăn({ }). Các thông tin trong một dãy hay đối tượng bao gồm tập hợp các cặp khóa/giá trị (Key/Value).",
      "Thông điệp JSON được chia thành các dãy (JSONArray)...",
      "Thông điệp JSON là các đối tượng(JObject)...",
      "Thông điệp JSON được chia thành các dãy (JSONArray) và đối tượng(JSONObject). Mỗi dãy được bắt đầu và kết thúc bởi cặp ngoặc vuông ([ ]) và mỗi đối tượng được bắt đầu và kết thúc bằng một cặp ngoặc quăn ({ }). Các thông tin trong một dãy hay đối tượng bao gồm tập hợp các cặp khóa/giá trị (Key/Value)."
    ],
    "answer": 3
  },
  {
    "q": "Để lập trình phát triển ứng dụng trên nền tảng gốc iOS, người lập trình gặp khó khăn gì?",
    "options": [
      "Ngôn ngữ lập trình được đánh giá là phức tạp.",
      "Tốn chi phí để đăng tuyển vào chương trình người phát triển iOS (tải SDK, cài đặt môi trường phát triển, kiểm thử trên thiết bị thật, đưa lên App Store).",
      "Môi trường phát triển ứng dụng iOS chỉ có thể cài đặt trên máy tính chạy hệ điều hành MacOS...",
      "Tất cả A, B và C đều đúng."
    ],
    "answer": 3
  },
  {
    "q": "Mỗi phiên bản của hệ điều hành Android có 3 tên đại diện là gì? Cho biết các tên này ứng với phiên bản mới nhất hiện nay (tính đến tháng 08/2023)?",
    "options": [
      "3 tên đại diện cho phiên bản là: Release number, Target name và API level. Tương ứng với phiên bản mới nhật hiện nay là Release number = 14, Target name = S và API level = 34.",
      "3 tên đại diện cho phiên bản là: Version number, Target name và API. Tương ứng với phiên bản mới nhật hiện nay là Version number = 12.0, Target name = S và API = 31.",
      "3 tên đại diện cho phiên bản là: Target, Release name và API level. Tương ứng với phiên bản mới nhật hiện nay là Target = 13, Release name = Tiramisu và API level = 33.",
      "3 tên đại diện cho phiên bản là: Target, Version name và API level. Tương ứng với phiên bản mới nhật hiện nay là Target = 12L, Release name = Sv2 và API level = 32."
    ],
    "answer": 2
  },
  {
    "q": "Kiến trúc của hệ điều hành Android bao gồm các tầng như sau:",
    "options": [
      "Linux Kernel; Application Framework; Virtual machine; Applications.",
      "Linux Kernel; Library; Android runtime; Application Framework; Applications.",
      "Unix Kernel; Library; Android runtime; Applications.",
      "Linux Kernel; Library - Android runtime; Application Framework; Applications."
    ],
    "answer": 1
  },
  {
    "q": "Một trong các ưu điểm của nền tảng Android là tính năng mở, tính năng mở có nghĩa là:",
    "options": [
      "Mã nguồn mở.",
      "Không tốn phí cho môi trường phát triển ứng dụng.",
      "Có thể chạy thử phần mềm trực tiếp trên máy thật trong khi lập trình phát triển.",
      "Tất cả A, B và C đều đúng."
    ],
    "answer": 3
  },
  {
    "q": "Trong 6 thành phần của ứng dụng Android có 4 thành phần chính cấu thành ứng dụng là:",
    "options": [
      "Activity, Service, Intent và Content Provider là 4 thành phần chính cấu thành nên ứng dụng Android, cần khai báo trong AndroidManifest.",
      "Activity, Service, Broadcast Receiver và Intent là 4 thành phần chính cấu thành nên ứng dụng Android, cần khai báo trong AndroidManifest.",
      "Activity, Service, Broadcast Receiver và Content Provider là 4 thành phần chính cấu thành nên ứng dụng Android, cần khai báo trong AndroidManifest.",
      "Activity, Intent, Broadcast Receiver và Content Provider là 4 thành phần chính cấu thành nên ứng dụng Android, cần khai báo trong AndroidManifest."
    ],
    "answer": 2
  },
  {
    "q": "Hiện nay có bao nhiêu cách để phát triển ứng dụng cho thiết bị di động? Cách nào là cơ bản nhất mà người phát triển ứng dụng cho thiết bị di động phải học trước tiên?",
    "options": [
      "Có 5 cách để phát triển ứng dụng cho thiết bị di động. Cách phát triển ứng dụng trên nền tảng gốc (Native platform) là cơ bản nhất.",
      "Có 4 cách để phát triển ứng dụng cho thiết bị di động. Cách phát triển ứng dụng trên nền tảng chéo (Cross platform) là cơ bản nhất.",
      "Có 5 cách để phát triển ứng dụng cho thiết bị di động. Cách phát triển ứng dụng kiểu lập trình nhúng là cơ bản nhất.",
      "Có 4 cách để phát triển ứng dụng cho thiết bị di động. Cách phát triển ứng dụng lai (Hydrid Apps) là cơ bản nhất."
    ],
    "answer": 0
  },
  {
    "q": "Khái niệm trừu tượng (abstraction) trong lập trình gồm những thành phần như:",
    "options": [
      "Những môi trường phát triển phần mềm (SDE).",
      "Là những phần mềm nằm giữa phần cứng và môi trường phát triển ứng dụng như: menu, database, file systems, related runtime libraries, API,…",
      "Máy ảo (Emulator).",
      "Là lớp (class) không thể được dùng để tạo ra các đối tượng như những lớp bình thường khác."
    ],
    "answer": 1
  },
  {
    "q": "IDE (integrated design environment hay integrated debugging environment) là:",
    "options": [
      "Một hệ điều hành hay một máy ảo(virtual machine) trên đỉnh của phần cứng, nó cho khả năng viết code một lần để phát triển ứng dụng chạy trên nhiều nền tảng.",
      "Một tổng thể(gồm cả phần cứng lẫn phần mềm)mà nó cung cấp toàn bộ các phương tiện để người lập trình máy tính phát triển phần mềm ứng dụng.",
      "Một môi trường lập trình hỗ trợ nhiều ngôn ngữ lập trình khác nhau để lập trình phát triển ứng dụng, sau đó biên dịch sang một ngôn ngữ trung gian (bytecode) và ứng dụng chỉ chạy trên một hệ điều hành.",
      "Một phần mềm ứng dụng mà nó cung cấp toàn bộ các phương tiện để người lập trình máy tính phát triển phần mềm ứng dụng trên một hoặc nhiều nền tảng."
    ],
    "answer": 3
  },
  {
    "q": "Kiến trúc Thin-Client Wireless Client-Server là",
    "options": [
      "Kiến trúc mà khi client truyền thông với server, nó có thể thực thi vài việc và server thực hiện các việc khác. Vì vậy không cần kết nối mạng liên tục và ổn định.",
      "Kiến trúc truyền thông theo giao thức TCP/IP.",
      "Kiến trúc mà ứng dụng được thực hiện bởi server. Vì vậy đòi hỏi client phải kết nối mạng liên tục và ổn định với server, tương ứng với tập các đặc tính kỹ thuật chung nhỏ nhất của các thiết bị và platform.",
      "Kiến trúc truyền thông theo giao thức UDP."
    ],
    "answer": 2
  },
  {
    "q": "Ứng dụng lai (Hybrid application) là ứng dụng như thế nào?",
    "options": [
      "Là ứng dụng cho thiết bị di động chạy trên nền web, được lập trình trên một môi trường phát triển chạy trên các thiết bị di động với các nền tảng khác nhau.",
      "Là ứng dụng có thể chạy đồng thời trên máy tính PC, trên Smart phone và Tablet.",
      "Là ứng dụng thể chạy đồng thời trên máy tính PC, trên Smart phone, Tablet và Mobile web.",
      "Là ứng dụng chỉ cần lập trình một lần trên một môi trường và có thể chạy trên nhiều nền tảng khác nhau."
    ],
    "answer": 2
  },
  {
    "q": "Quá trình phát triển của mạng viễn thông di động trải qua các thế hệ 1G, 2G, 3G, 4G, 5G. Sự chuyển đổi từ kỹ thuật tương tự (analog) sang kỹ thuật số (digital) diễn ra trong thế hệ nào?",
    "options": [
      "Áp dụng kỹ thuật số ngay từ đầu.",
      "3G",
      "4G",
      "2G"
    ],
    "answer": 3
  },
  {
    "q": "Phân biệt mạng Piconet và Scatternet trong kỹ thuật Bluetooth",
    "options": [
      "Scatternet là mạng liên kết các thiết bị cùng cấp, Piconet là mạng liên kết giữa các Scatternet.",
      "Piconet là mạng liên kết các thiết bị cùng cấp, Scatternet là mạng liên kết giữa các Piconet.",
      "Piconet là mạng liên kết các thiết bị cùng loại, Scatternet là mạng liên kết giữa các thiết bị khác loại.",
      "Piconet là mạng liên kết các thiết bị khác loại, Scatternet là mạng liên kết giữa các thiết bị cùng loại."
    ],
    "answer": 1
  },
  {
    "q": "Điện thoại Android đầu tiên tên gì? Ra mắt năm nào?",
    "options": [
      "T-Mobile G1 – 1, 2008",
      "Nexus – one, 2008",
      "T-Mobile G1 – 1, 2007",
      "HTC One, 2008"
    ],
    "answer": 0
  },
  {
    "q": "Các bước lập trình xử lý tương tác của người dùng lên các View như sau:",
    "options": [
      "Khai báo View trong Layout → Ánh xạ View này vào Activity tương ứng bằng phương thức findViewById... → Sử dụng phương thức setOnClickListener() kết hợp với onClick().",
      "Khai báo View trong Layout → Tạo phương thức xử lý tương tác... → Khai báo thuộc tính onClick cho View trong tập tin Layout như sau: android:onClick=”ptTuongtac”.",
      "Các câu trả lời A và B đều đúng.",
      "Câu trả lời A đúng và câu trả lời B sai."
    ],
    "answer": 2
  },
  {
    "q": "Menu rất hữu ích để hiển thị tùy chọn bổ sung mà không trực tiếp nhìn thấy trên giao diện của một Activity. Trong đó, Context Menu có chức năng và đặc điểm là:",
    "options": [
      "Hiển thị những thông tin liên quan đến Activity hiện tại. Menu này thường nằm ở góc phải phía trên...",
      "Hiển thị những thông tin liên quan đến ứng dụng. Menu này thường nằm ở góc phải phía trên của giao diện của tất cả Activity...",
      "Hiển thị những thông tin liên quan đến một đối tượng View cụ thể, để kích hoạt menu này người dùng chỉ cần nhấn vào đối tượng View...",
      "Hiển thị những thông tin liên quan đến một đối tượng View cụ thể, để kích hoạt menu này người dùng cần nhấn và giữ đối tượng View mà nó liên kết."
    ],
    "answer": 3
  },
  {
    "q": "Các bước để thực hiện một Intent ngầm (Implicit Intent) gồm:",
    "options": [
      "Bước 1: Định nghĩa dữ liệu kèm theo dưới dạng Uri; Bước 2: Khai báo một Intent với 1 Action cụ thể và Uri đã định nghĩa; Bước 3: Gọi hàm startActivity() hoặc startActivityForResult()...",
      "Bước 1: Khai báo một Intent với 1 Action cụ thể; Bước 2: Gọi hàm startActivity()...; Bước 3: Khai báo View cần thiết...",
      "Bước 1: Khai báo View cần thiết...; Bước 2: Khai báo một Intent...; Bước 3: Gọi hàm startActivity()...",
      "Bước 1: Khai báo một Intent với 1 Action cụ thể; Bước 2: Định nghĩa dữ liệu kèm theo dưới dạng Bundle; Bước 3: Gọi hàm startActivity()..."
    ],
    "answer": 0
  },
  {
    "q": "Trong thiết bị di động, bộ nhớ trong và bộ nhớ ngoài được phân biệt như sau:",
    "options": [
      "Bộ nhớ trong là bộ nhớ RAM, bộ nhớ ngoài là bộ nhớ ROM.",
      "Bộ nhớ trong là bộ nhớ được gắn sẵn trong thiết bị, bộ nhớ ngoài là SDCard.",
      "Bộ nhớ trong chỉ được dùng để lưu dữ liệu riêng của mỗi ứng dụng, bộ nhớ ngoài dùng để lưu dữ liệu dùng chung...",
      "Bộ nhớ trong gồm RAM và bộ nhớ được gắn sẵn trong thiết bị, bộ nhớ ngoài là SDCard."
    ],
    "answer": 1
  },
  {
    "q": "Đối tượng Preferences thường dùng để lưu trữ, điều chỉnh và phục hồi nội dung gì?",
    "options": [
      "Tập các tính năng của ứng dụng được người dùng tuỳ chọn.",
      "Các thiết lập của người dùng trong một ứng dụng.",
      "Tập các hoạt động của ứng dụng được người dùng tuỳ chọn.",
      "Tất cả A, B, C đều đúng."
    ],
    "answer": 3
  },
  {
    "q": "Các đối tượng được dùng để xây dựng thiết lập trong Android gồm:",
    "options": [
      "ListboxPreference; ViewPreference; FramePreference.",
      "CheckBoxPreference; ListPreference; EditTextPreference.",
      "PreferenceFragment; PreferenceActivity.",
      "Tất cả A, B và C đều sai."
    ],
    "answer": 1
  },
  {
    "q": "Tạo bảng: tên là Lop_CT274, gồm 7 cột: ID, MSSV, Họ_Tên, Email, Diem_KT, Điểm_Thi, Điểm_TH. Hãy viết chuỗi tạo bảng.",
    "options": [
      "String CreatetbSchool=\"create table Lop_CT274 (\"+\"id integer primary key autoincrement,\"+“MSSV text, \"+“Ho_Ten text, \"+“Email text, \"+“Diem_KT float, \"+“Diem_Thi float, \"+“Diem_TH float)\");",
      "String CreatetbSchool=\"create table Lop_CT274 (+”id integer primary key autoincrement”,+”MSSV” text, ...",
      "String CreatetbSchool=\"table Lop_CT274 (\"+\"id integer key autoincrement,\"+...",
      "Các câu khác với câu này đều sai."
    ],
    "answer": 0
  },
  {
    "q": "Để thao tác với cơ sở dữ liệu SQLite trên Android ta sử dụng các đối tượng nào?",
    "options": [
      "SQLiteOpenController và SQLiteDatabase.",
      "SQLiteOpenHelper và SQLiteDatabase.",
      "SQLiteData và SQLiteOpenManager.",
      "SQLiteOpenHelper và SQLiteDataContent"
    ],
    "answer": 1
  },
  {
    "q": "Trong Android có nhiều Content Provider hữu dụng được dựng sẵn như CallLog, Contacts, MediaStore, Settings. Để truy vấn một Content Provider, chẳng hạn như lấy tất cả các contacts từ một Contacts content provider, chúng ta khai báo URI như sau:",
    "options": [
      "content://contacts/people",
      "provider://contacts/people",
      "contentprovider://contacts/people",
      "provider://content/contacts/people"
    ],
    "answer": 0
  },
  {
    "q": "Để xóa bảng trong cơ sở dữ liệu SQLite, giả sử có tên là db, ta áp dụng phương thức:",
    "options": [
      "db.deleteDatabase(<tên Bảng>)",
      "db.execSQL(“Chuỗi xóa bảng”)",
      "db.delete(“Tên bảng”)",
      "db.deleteTable(<tên Bảng>)"
    ],
    "answer": 1
  },
  {
    "q": "Để tạo ra một đối tượng con trỏ dùng để đọc tin nhắn trong thư mục inbox ta dùng phương thức nào? Cú pháp?",
    "options": [
      "Dùng phương thức getSmsContent và phương thức query...",
      "Dùng phương thức getContent và phương thức query...",
      "Dùng phương thức getContent và phương thức getquery...",
      "Dùng phương thức getContentResolver và phương thức query, với cú pháp: Cursor c = getContentResolver().query(SMS_INBOX, null, null, null, null);"
    ],
    "answer": 3
  },
  {
    "q": "Yêu cầu GET trong giao thức HTTP có đặc điểm gì?",
    "options": [
      "Yêu cầu thông tin - dữ liệu được chuyển đi như là một phần của URL, được dùng để gởi dữ liệu đến server và đây là phương thức mặc định.",
      "Yêu cầu thông tin - dữ liệu được chuyển đi trong luồng riêng biệt, dùng để gởi dữ liệu đến server.",
      "Yêu cầu thông tin - dữ liệu được chuyển đi như là một phần của URL, được dùng để lấy dữ liệu từ server và đây là phương thức mặc định.",
      "Yêu cầu thông tin - dữ liệu được chuyển đi với 2 phần riêng biệt gồm URL và dữ liệu trong cùng một luồng..."
    ],
    "answer": 2
  },
  {
    "q": "Để có thể thực hiện các cuộc giao tiếp, một trong hai quá trình phải công bố số hiệu cổng của socket mà mình sử dụng. Ngoài số hiệu cổng, hai bên giao tiếp còn phải biết địa chỉ IP của nhau. Cho biết vai trò của số hiệu cổng và địa chỉ IP.",
    "options": [
      "Số hiệu cổng và IP là một cặp để xác định server hoặc client.",
      "Cổng đề xác định đường truyền, địa chỉ IP để xác định thiết bị trên mạng TCP/IP.",
      "Địa chỉ IP giúp phân biệt các thiết bị trên mạng TCP/IP. Trong khi số hiệu cổng dùng để phân biệt các quá trình khác nhau trên cùng một máy tính.",
      "Số hiệu cổng và địa chỉ IP đều bắt buộc khai báo trong mọi trường hợp cho cả client và server."
    ],
    "answer": 2
  },
  {
    "q": "Hoạt động mạng là yêu cầu cơ bản và đã được thiết kế sẵn cho hầu hết các thiết bị di động. Như vậy, trong trường hợp nào người lập trình phát triển ứng dụng di động cần phải lập trình kết nối mạng cho thiết bị di động?",
    "options": [
      "Nguyên tắc chung cho các ứng dụng di động là phải có kết nối mạng...",
      "Khi xây dựng một ứng dụng có các chức năng cần phải kết nối mạng, người phát triển phần mềm cần lập trình mạng cho ứng dụng của mình.",
      "Vì các hoạt động mạng đã được thiết kế sẵn trên tất cả các thiết bị di động, nên người lập trình ứng dụng di động không cần lập trình kết nối mạng.",
      "Người lập trình phát triển ứng dụng di động luôn luôn phải thực hiện nội dung này trong khi lập trình..."
    ],
    "answer": 1
  },
  {
    "q": "Cấu trúc ngôn ngữ JSON?",
    "options": [
      "Thông điệp JSON được chia thành các đối tượng(JSONObject)...",
      "Thông điệp JSON được chia thành các dãy (JSONArray)...",
      "Thông điệp JSON là các đối tượng(JObject)...",
      "Thông điệp JSON được chia thành các dãy (JSONArray) và đối tượng(JSONObject). Mỗi dãy được bắt đầu và kết thúc bởi cặp ngoặc vuông ([ ]) và mỗi đối tượng được bắt đầu và kết thúc bằng một cặp ngoặc quăn ({ }). Các thông tin trong một dãy hay đối tượng bao gồm tập hợp các cặp khóa/giá trị (Key/Value)."
    ],
    "answer": 3
  },
  {
    "q": "Các bước lập trình để kiểm tra tình trạng kết nối mạng:",
    "options": [
      "Bước 1. Tạo ra đối tượng quản lý kết nối với lớp ConnectivityActive... (câu A sai chính tả)",
      "Bước 1. Tạo ra đối tượng quản lý kết nối với lớp ConnectivityNetwork... (câu B sai chính tả)",
      "Bước 1. Tạo ra đối tượng quản lý kết nối với lớp ConnectivityActive... (câu C sai chính tả)",
      "Tất cả A, B và C đều sai."
    ],
    "answer": 3
  },
  {
    "q": "Lớp nào được sử dụng để mở 1 kết nối http với URL từ xa? Cú pháp?",
    "options": [
      "Có thể dùng lớp HttpConnection và hàm getConnection()...",
      "Có thể dùng lớp URLConnection và hàm openConnection()...",
      "Có thể dùng lớp ConnectionUrl và hàm urlConnection()...",
      "Tất cả A, B và C đều sai."
    ],
    "answer": 1
  },
  {
    "q": "Để lập trình phát triển ứng dụng trên nền tảng gốc iOS, người lập trình gặp khó khăn gì?",
    "options": [
      "Ngôn ngữ lập trình được đánh giá là phức tạp.",
      "Tốn chi phí để đăng tuyển vào chương trình người phát triển iOS...",
      "Môi trường phát triển ứng dụng iOS chỉ có thể cài đặt trên máy tính chạy hệ điều hành MacOS...",
      "Tất cả A, B và C đều đúng."
    ],
    "answer": 3
  },
  {
    "q": "Explicit Intents là:",
    "options": [
      "Intent đã được xác định thuộc tính component, nghĩa là đã chỉ rõ thành phần sẽ nhận và xử lý. Explicit Intent thường được sử dụng để khởi chạy các activity trong cùng một ứng dụng.",
      "Intent cần khai báo rõ các thuộc tính action, data.",
      "Intent thường được sử dụng để khởi chạy các ứng dụng đã được cài đặt trên thiết bị.",
      "Intent được chỉ xác định hành động cần thực hiện khi không chỉ định thành phần cần gọi để xử lý."
    ],
    "answer": 0
  },
  {
    "q": "Lập trình giao diện người dùng mức cao là:",
    "options": [
      "Cách tạo giao diện người dùng tùy biến bằng các đối tượng do người lập trình tạo ra.",
      "Cách lập trình xây dựng giao diện người dùng sử dụng các kiểu giao diện được định nghĩa (Layout) và các đối tượng có sẵn (View) trong Android SDK.",
      "Cách lập trình sử dụng công cụ kéo thả trong Android Studio.",
      "Cách lập trình viết cách viết code mà không dùng công cụ kéo thả trong Android Studio."
    ],
    "answer": 1
  },
  {
    "q": "Khi sử dụng LinearLayout cần phải khai báo thêm thuộc tính gì?",
    "options": [
      "Thuộc tính android:layout_gravity.",
      "Thuộc tính android:orientation.",
      "Không bắt buộc khai báo thêm.",
      "Thuộc tính android:layout_width và android:layout_height."
    ],
    "answer": 1
  },
  {
    "q": "Trong Android, để Activity (giả sử viết bằng ngôn ngữ Java) hiển thị một giao diện ta sử dụng phương thức và câu lệnh như sau (Giả sử “giaodien” là tên giao diện được chọn để hiển thị):",
    "options": [
      "setLayoutView(R.layout.giaodien);",
      "setIntentView(R.layout.giaodien);",
      "setContentLayout(R.layout.giaodien);",
      "setContentView(R.layout.giaodien);"
    ],
    "answer": 3
  },
  {
    "q": "Để sử dụng đối tượng ImageView ta phải lưu tên tập tin của ảnh muốn hiển thị vào đâu và câu lệnh bắt buộc (không mặc định) trong mã nguồn xml là gì?",
    "options": [
      "Lưu ảnh vào thư mục res/drawable và câu lệnh xml bắt buộc phải khai báo là android:src=”@drawable/”tên tập tin ảnh”.",
      "Lưu ảnh vào thư mục res/layout và câu lệnh xml bắt buộc phải khai báo là android:contentDescription=”@drawable/”tên tập tin ảnh”.",
      "Lưu ảnh vào thư mục res/mipmap và câu lệnh xml bắt buộc phải khai báo là android:src=”@drawable/”tên tập tin ảnh”.",
      "Tất cả A, B và C đều sai."
    ],
    "answer": 0
  },
  {
    "q": "Cách ánh xạ một View trong tập tin Layout.xml vào mã nguồn Java của Activity tương ứng? Cho ví dụ.",
    "options": [
      "Dùng phương thức setContentView(R.id.tên định danh của View); ...",
      "Dùng phương thức findViewById(R.id.tên định danh của View); ...",
      "Dùng phương thức getViewById(R.layout.R.layout.tên định danh của View); ...",
      "Tất cả A, B và C đều sai."
    ],
    "answer": 1
  },
  {
    "q": "Bằng cách gom nhóm các RadioButton vào một RadioGroup cho phép:",
    "options": [
      "Có thể check nhiều RadioButton trong cùng một nhóm.",
      "Khi check một RadioButton thì tất cả các RadioButton trong cùng nhóm đều được check",
      "Chỉ được check chọn một RadioButton trong cùng một nhóm.",
      "Tuỳ thuộc vào giá trị của thuộc tính check được khai báo trong tập tin layout..."
    ],
    "answer": 2
  },
  {
    "q": "Activity là thành phần trong một ứng dụng Android:",
    "options": [
      "Trong mỗi ứng dụng đều phải có Activity.",
      "Mỗi Activity tương ứng với một giao diện người dùng.",
      "Một ứng dụng có thể có một hoặc nhiều Activity.",
      "Tất cả các câu trả lời đúng."
    ],
    "answer": 3
  },
  {
    "q": "Khi mở project mới ta cần khai báo chọn bao nhiêu phiên bản, những phiên bản nào? Tại sao?",
    "options": [
      "Cần khai báo 3 phiên bản: 1 để biên dịch (mới nhất, mặc định), 1 phiên bản cũ nhất có thể chạy được ứng dụng và 1 phiên bản trung gian để chạy thử ứng dụng.",
      "Cần khai báo từ 3 phiên bản trở lên: 1 để biên dịch (mới nhất), 1 phiên bản cũ nhất có thể chạy được ứng dụng và các phiên bản trung gian để chạy thử ứng dụng bằng máy ảo.",
      "Cần khai báo 2 phiên bản: 1 để biên dịch (mới nhất, mặc định), 1 phiên bản cũ nhất có thể chạy được ứng dụng.",
      "Cần khai báo 1 phiên bản mới nhất (mặc định)."
    ],
    "answer": 2
  },
  {
    "q": "Người lập trình phát triển ứng dụng có thể kết hợp giao diện mức cao và mức thấp bằng cách nào?",
    "options": [
      "Trong giao diện mức cao ta có thể lồng vào giao diện mức thấp.",
      "Trong giao diện mức thấp ta có thể lồng vào giao diện mức cao.",
      "Từ Activity có giao diện mức thấp gọi Activity có giao diện mức cao hoặc ngược lại.",
      "Tất cả các câu trả lời đều đúng."
    ],
    "answer": 3
  },
  {
    "q": "Để thao tác với cơ sở dữ liệu SQLite trên Android ta sử dụng các đối tượng nào?",
    "options": [
      "SQLiteOpenController và SQLiteDatabase",
      "SQLiteOpenHelper và SQLiteDatabase",
      "SQLiteData và SQLiteOpenManager",
      "SQLiteOpenHelper và SQLiteDataContent"
    ],
    "answer": 1
  },
  {
    "q": "Trong Android có nhiều Content Provider hữu dụng được dựng sẵn như CallLog, Contacts, MediaStore, Settings. Để truy vấn một Content Provider, chẳng hạn như lấy tất cả các contacts từ một Contacts content provider, chúng ta khai báo URI như sau:",
    "options": [
      "contentprovider://contacts/people",
      "provider://contacts/people",
      "content://contacts/people",
      "provider://content/contacts/people"
    ],
    "answer": 2
  },
  {
    "q": "Để xóa bảng trong cơ sở dữ liệu SQLite, giả sử có tên là db, ta áp dụng phương thức:",
    "options": [
      "db.deleteDatabase(<tên Bảng>)",
      "db.execSQL(“Chuỗi xóa bảng”)",
      "db.delete(“Tên bảng”)",
      "db.deleteTable(<tên Bảng>)"
    ],
    "answer": 1
  },
  {
    "q": "Để tạo ra một đối tượng con trỏ dùng để đọc tin nhắn trong thư mục inbox ta dùng phương thức nào? Cú pháp?",
    "options": [
      "Dùng phương thức getSmsContent và phương thức query...",
      "Dùng phương thức getContent và phương thức query...",
      "Dùng phương thức getContent và phương thức getquery...",
      "Dùng phương thức getContentResolver và phương thức query, với cú pháp: Cursor c = getContentResolver().query(SMS_INBOX, null, null, null, null);"
    ],
    "answer": 3
  },
  {
    "q": "Yêu cầu GET trong giao thức HTTP có đặc điểm gì?",
    "options": [
      "Yêu cầu thông tin - dữ liệu được chuyển đi như là một phần của URL, được dùng để lấy dữ liệu từ server và đây là phương thức mặc định.",
      "Yêu cầu thông tin - dữ liệu được chuyển đi trong luồng riêng biệt, dùng để gởi dữ liệu đến server.",
      "Yêu cầu thông tin - dữ liệu được chuyển đi như là một phần của URL, được dùng để gởi dữ liệu đến server và đây là phương thức mặc định.",
      "Yêu cầu thông tin - dữ liệu được chuyển đi với 2 phần riêng biệt gồm URL và dữ liệu trong cùng một luồng..."
    ],
    "answer": 0
  },
  {
    "q": "Để có thể thực hiện các cuộc giao tiếp, một trong hai quá trình phải công bố số hiệu cổng của socket mà mình sử dụng. Ngoài số hiệu cổng, hai bên giao tiếp còn phải biết địa chỉ IP của nhau. Cho biết vai trò của số hiệu cổng và địa chỉ IP.",
    "options": [
      "Số hiệu cổng và IP là một cặp để xác định server hoặc client.",
      "Địa chỉ IP giúp phân biệt các thiết bị trên mạng TCP/IP. Trong khi số hiệu cổng dùng để phân biệt các quá trình khác nhau trên cùng một máy tính.",
      "Cổng đề xác định đường truyền, địa chỉ IP để xác định thiết bị trên mạng TCP/IP.",
      "Số hiệu cổng và địa chỉ IP đều bắt buộc khai báo trong mọi trường hợp cho cả client và server."
    ],
    "answer": 1
  },
  {
    "q": "Hoạt động mạng là yêu cầu cơ bản và đã được thiết kế sẵn cho hầu hết các thiết bị di động. Như vậy, trong trường hợp nào người lập trình phát triển ứng dụng di động cần phải lập trình kết nối mạng cho thiết bị di động?",
    "options": [
      "Khi xây dựng một ứng dụng có các chức năng cần phải kết nối mạng, người phát triển phần mềm cần lập trình mạng cho ứng dụng của mình.",
      "Nguyên tắc chung cho các ứng dụng di động là phải có kết nối mạng...",
      "Vì các hoạt động mạng đã được thiết kế sẵn trên tất cả các thiết bị di động, nên người lập trình ứng dụng di động không cần lập trình kết nối mạng.",
      "Người lập trình phát triển ứng dụng di động luôn luôn phải thực hiện nội dung này trong khi lập trình..."
    ],
    "answer": 0
  },
  {
    "q": "Các bước lập trình để kiểm tra tình trạng kết nối mạng:",
    "options": [
      "Bước 1. Tạo ra đối tượng quản lý kết nối với lớp ConnectivityActive... (câu A sai chính tả)",
      "Bước 1. Tạo ra đối tượng quản lý kết nối với lớp ConnectivityNetwork... (câu B sai chính tả)",
      "Bước 1. Tạo ra đối tượng quản lý kết nối với lớp ConnectivityActive... (câu C sai chính tả)",
      "Tất cả A, B và C đều sai."
    ],
    "answer": 3
  },
  {
    "q": "Lớp nào được sử dụng để mở 1 kết nối http với URL từ xa? Cú pháp?",
    "options": [
      "Có thể dùng lớp HttpConnection và hàm getConnection()...",
      "Có thể dùng lớp URLConnection và hàm openConnection(), cú pháp: URL url=new URL(urlString); URLConnection conn= url.openConnection();",
      "Có thể dùng lớp ConnectionUrl và hàm urlConnection()...",
      "Tất cả A, B và C đều sai."
    ],
    "answer": 1
  },
  {
    "q": "Cấu trúc ngôn ngữ JSON?",
    "options": [
      "Thông điệp JSON được chia thành các đối tượng(JSONObject)...",
      "Thông điệp JSON được chia thành các dãy (JSONArray)...",
      "Thông điệp JSON là các đối tượng(JObject)...",
      "Thông điệp JSON được chia thành các dãy (JSONArray) và đối tượng(JSONObject). Mỗi dãy được bắt đầu và kết thúc bởi cặp ngoặc vuông ([ ]) và mỗi đối tượng được bắt đầu và kết thúc bằng một cặp ngoặc quăn ({ }). Các thông tin trong một dãy hay đối tượng bao gồm tập hợp các cặp khóa/giá trị (Key/Value)."
    ],
    "answer": 3
  },
  {
    "q": "Để lập trình phát triển ứng dụng trên nền tảng gốc iOS, người lập trình gặp khó khăn gì?",
    "options": [
      "Ngôn ngữ lập trình được đánh giá là phức tạp.",
      "Tốn chi phí để đăng tuyển vào chương trình người phát triển iOS...",
      "Môi trường phát triển ứng dụng iOS chỉ có thể cài đặt trên máy tính chạy hệ điều hành MacOS...",
      "Tất cả A, B và C đều đúng."
    ],
    "answer": 3
  },
  {
    "q": "Một trong các ưu điểm của nền tảng Android là tính năng mở, tính năng mở có nghĩa là:",
    "options": [
      "Mã nguồn mở.",
      "Không tốn phí cho môi trường phát triển ứng dụng.",
      "Có thể chạy thử phần mềm trực tiếp trên máy thật trong khi lập trình phát triển.",
      "Tất cả các câu trả lời đều đúng."
    ],
    "answer": 3
  },
  {
    "q": "Trong 6 thành phần của ứng dụng Android có 4 thành phần chính cấu thành ứng dụng là:",
    "options": [
      "Activity, Service, Broadcast Receiver và Content Provider là 4 thành phần chính cấu thành nên ứng dụng Android, cần khai báo trong AndroidManifest.",
      "Activity, Service, Broadcast Receiver và Intent là 4 thành phần chính cấu thành nên ứng dụng Android, cần khai báo trong AndroidManifest.",
      "Activity, Service, Intent và Content Provider là 4 thành phần chính cấu thành nên ứng dụng Android, cần khai báo trong AndroidManifest.",
      "Activity, Intent, Broadcast Receiver và Content Provider là 4 thành phần chính cấu thành nên ứng dụng Android, cần khai báo trong AndroidManifest."
    ],
    "answer": 0
  },
  {
    "q": "Quá trình phát triển của mạng viễn thông di động trải qua các thế hệ 1G, 2G, 3G, 4G, 5G. Sự chuyển đổi từ kỹ thuật tương tự (analog) sang kỹ thuật số (digital) diễn ra trong thế hệ nào?",
    "options": [
      "2G",
      "3G",
      "4G",
      "Áp dụng kỹ thuật số ngay từ đầu."
    ],
    "answer": 0
  },
  {
    "q": "Activity là thành phần trong một ứng dụng Android:",
    "options": [
      "Trong mỗi ứng dụng đều phải có Activity.",
      "Mỗi Activity tương ứng với một giao diện người dùng.",
      "Một ứng dụng có thể có một hoặc nhiều Activity.",
      "Tất cả các câu trả lời đúng."
    ],
    "answer": 3
  },
  {
    "q": "Khi mở project mới ta cần khai báo chọn bao nhiêu phiên bản, những phiên bản nào? Tại sao?",
    "options": [
      "Cần khai báo 3 phiên bản: 1 để biên dịch (mới nhất, mặc định), 1 phiên bản cũ nhất có thể chạy được ứng dụng và 1 phiên bản trung gian để chạy thử ứng dụng.",
      "Cần khai báo từ 3 phiên bản trở lên...",
      "Cần khai báo 2 phiên bản: 1 để biên dịch (mới nhất, mặc định), 1 phiên bản cũ nhất có thể chạy được ứng dụng.",
      "Cần khai báo 1 phiên bản mới nhất (mặc định)."
    ],
    "answer": 2
  },
  {
    "q": "Explicit Intents là:",
    "options": [
      "Intent được chỉ xác định hành động cần thực hiện khi không chỉ định thành phần cần gọi để xử lý.",
      "Intent cần khai báo rõ các thuộc tính action, data.",
      "Intent thường được sử dụng để khởi chạy các ứng dụng đã được cài đặt trên thiết bị.",
      "Intent đã được xác định thuộc tính component, nghĩa là đã chỉ rõ thành phần sẽ nhận và xử lý. Explicit Intent thường được sử dụng để khởi chạy các activity trong cùng một ứng dụng."
    ],
    "answer": 3
  },
  {
    "q": "Lập trình giao diện người dùng mức cao là:",
    "options": [
      "Cách tạo giao diện người dùng tùy biến bằng các đối tượng do người lập trình tạo ra.",
      "Cách lập trình xây dựng giao diện người dùng sử dụng các kiểu giao diện được định nghĩa (Layout) và các đối tượng có sẵn (View) trong Android SDK.",
      "Cách lập trình sử dụng công cụ kéo thả trong Android Studio.",
      "Cách lập trình viết cách viết code mà không dùng công cụ kéo thả trong Android Studio."
    ],
    "answer": 1
  },
  {
    "q": "Khi sử dụng LinearLayout cần phải khai báo thêm thuộc tính gì?",
    "options": [
      "Thuộc tính android:orientation.",
      "Thuộc tính android:layout_gravity.",
      "Không bắt buộc khai báo thêm.",
      "Thuộc tính android:layout_width và android:layout_height."
    ],
    "answer": 0
  },
  {
    "q": "Trong Android, để Activity (giả sử viết bằng ngôn ngữ Java) hiển thị một giao diện ta sử dụng phương thức và câu lệnh như sau (Giả sử “giaodien” là tên giao diện được chọn để hiển thị):",
    "options": [
      "setLayoutView(R.layout.giaodien);",
      "setIntentView(R.layout.giaodien);",
      "setContentView(R.layout.giaodien);",
      "setContentLayout(R.layout.giaodien);"
    ],
    "answer": 2
  },
  {
    "q": "Kiến trúc Thin-Client Wireless Client-Server là:",
    "options": [
      "Kiến trúc mà khi client truyền thông với server, nó có thể thực thi vài việc và server thực hiện các việc khác. Vì vậy không cần kết nối mạng liên tục và ổn định.",
      "Kiến trúc mà ứng dụng được thực hiện bởi server. Vì vậy đòi hỏi client phải kết nối mạng liên tục và ổn định với server...",
      "Kiến trúc truyền thông theo giao thức TCP/IP.",
      "Kiến trúc truyền thông theo giao thức UDP."
    ],
    "answer": 0
  },
  {
    "q": "Để sử dụng đối tượng ImageView ta phải lưu tên tập tin của ảnh muốn hiển thị vào đâu và câu lệnh bắt buộc (không mặc định) trong mã nguồn xml là gì?",
    "options": [
      "Lưu ảnh vào thư mục res/drawable và câu lệnh xml bắt buộc phải khai báo là android:src=”@drawable/”tên tập tin ảnh”.",
      "Lưu ảnh vào thư mục res/layout và câu lệnh xml bắt buộc phải khai báo là android:contentDescription=”@drawable/”tên tập tin ảnh”.",
      "Lưu ảnh vào thư mục res/mipmap và câu lệnh xml bắt buộc phải khai báo là android:src=”@drawable/”tên tập tin ảnh”.",
      "Tất cả A, B và C đều sai."
    ],
    "answer": 0
  },
  {
    "q": "Phân biệt mạng Piconet và Scatternet trong kỹ thuật Bluetooth",
    "options": [
      "Scatternet là mạng liên kết các thiết bị cùng cấp, Piconet là mạng liên kết giữa các Scatternet.",
      "Piconet là mạng liên kết các thiết bị cùng cấp, Scatternet là mạng liên kết giữa các Piconet.",
      "Piconet là mạng liên kết các thiết bị cùng loại, Scatternet là mạng liên kết giữa các thiết bị khác loại.",
      "Piconet là mạng liên kết các thiết bị khác loại, Scatternet là mạng liên kết giữa các thiết bị cùng loại."
    ],
    "answer": 1
  },
  {
    "q": "Hiện nay có bao nhiêu cách để phát triển ứng dụng cho thiết bị di động? Cách nào là cơ bản nhất mà người phát triển ứng dụng cho thiết bị di động phải học trước tiên?",
    "options": [
      "Có 4 cách... Cross platform là cơ bản nhất.",
      "Có 5 cách... Native platform là cơ bản nhất.",
      "Có 5 cách... lập trình nhúng là cơ bản nhất.",
      "Có 4 cách... Hybrid Apps là cơ bản nhất."
    ],
    "answer": 1
  },
  {
    "q": "Khái niệm trừu tượng (abstraction) trong lập trình gồm những thành phần như:",
    "options": [
      "Những môi trường phát triển phần mềm (SDE).",
      "Là những phần mềm nằm giữa phần cứng và môi trường phát triển ứng dụng như: menu, database, file systems, related runtime libraries, API,…",
      "Máy ảo (Emulator).",
      "Là lớp (class) không thể được dùng để tạo ra các đối tượng..."
    ],
    "answer": 1
  },
  {
    "q": "IDE (integrated design environment hay integrated debugging environment) là:",
    "options": [
      "Một hệ điều hành hay một máy ảo(virtual machine)...",
      "Một tổng thể (gồm cả phần cứng lẫn phần mềm)...",
      "Một phần mềm ứng dụng mà nó cung cấp toàn bộ các phương tiện để người lập trình máy tính phát triển phần mềm ứng dụng trên một hoặc nhiều nền tảng.",
      "Một môi trường lập trình hỗ trợ nhiều ngôn ngữ... biên dịch sang bytecode..."
    ],
    "answer": 2
  },
  {
    "q": "Kiến trúc của hệ điều hành Android bao gồm các tầng như sau:",
    "options": [
      "Linux Kernel; Library - Android runtime; Application Framework; Applications.",
      "Linux Kernel; Library; Android runtime; Application Framework; Applications.",
      "Unix Kernel; Library; Android runtime; Applications.",
      "Linux Kernel; Application Framework; Virtual machine; Applications."
    ],
    "answer": 0
  },
  {
    "q": "Ứng dụng lai (Hybrid application) là ứng dụng như thế nào?",
    "options": [
      "Là ứng dụng chỉ cần lập trình một lần trên một môi trường và có thể chạy trên nhiều nền tảng khác nhau.",
      "Là ứng dụng có thể chạy đồng thời trên máy tính PC, trên Smart phone và Tablet.",
      "Là ứng dụng thể chạy đồng thời trên máy tính PC, trên Smart phone, Tablet và Mobile web.",
      "Là ứng dụng cho thiết bị di động chạy trên nền web..."
    ],
    "answer": 2
  },
  {
    "q": "Điện thoại Android đầu tiên tên gì? Ra mắt năm nào?",
    "options": [
      "T-Mobile G1 – 1, 2007",
      "Nexus – one, 2008",
      "T-Mobile G1 – 1, 2008",
      "HTC One, 2008"
    ],
    "answer": 2
  },
  {
    "q": "Mỗi phiên bản của hệ điều hành Android có 3 tên đại diện là gì? Cho biết các tên này ứng với phiên bản mới nhất hiện nay (tính đến tháng 08/2023)?",
    "options": [
      "Release number = 14, Target name = S và API level = 34.",
      "Version number = 12.0, Target name = S và API = 31.",
      "Target = 12L, Release name = Sv2 và API level = 32.",
      "Target = 13, Release name = Tiramisu và API level = 33."
    ],
    "answer": 3
  },
  {
    "q": "Cách ánh xạ một View trong tập tin Layout.xml vào mã nguồn Java của Activity tương ứng? Cho ví dụ.",
    "options": [
      "Dùng phương thức setContentView(R.id.tên định danh của View); ...",
      "Dùng phương thức findViewById(R.id.tên định danh của View); ...",
      "Dùng phương thức getViewById(R.layout.R.layout.tên định danh của View); ...",
      "Tất cả A, B và C đều sai."
    ],
    "answer": 1
  },
  {
    "q": "Bằng cách gom nhóm các RadioButton vào một RadioGroup cho phép:",
    "options": [
      "Có thể check nhiều RadioButton trong cùng một nhóm.",
      "Chỉ được check chọn một RadioButton trong cùng một nhóm.",
      "Khi check một RadioButton thì tất cả các RadioButton trong cùng nhóm đều được check.",
      "Tuỳ thuộc vào giá trị của thuộc tính check..."
    ],
    "answer": 1
  },
  {
    "q": "Người lập trình phát triển ứng dụng có thể kết hợp giao diện mức cao và mức thấp bằng cách nào?",
    "options": [
      "Trong giao diện mức cao ta có thể lồng vào giao diện mức thấp.",
      "Trong giao diện mức thấp ta có thể lồng vào giao diện mức cao.",
      "Từ Activity có giao diện mức thấp gọi Activity có giao diện mức cao hoặc ngược lại.",
      "Tất cả A, B và C đều đúng."
    ],
    "answer": 3
  },
  {
    "q": "Các bước lập trình xử lý tương tác của người dùng lên các View như sau:",
    "options": [
      "Khai báo View → findViewById → setOnClickListener() + onClick().",
      "Khai báo View → Tạo phương thức ptTuongtac → android:onClick=”ptTuongtac”.",
      "Các câu trả lời A và B đều đúng.",
      "Câu trả lời A đúng và câu trả lời B sai."
    ],
    "answer": 2
  },
  {
    "q": "Menu rất hữu ích để hiển thị tùy chọn bổ sung mà không trực tiếp nhìn thấy trên giao diện của một Activity. Trong đó, Context Menu có chức năng và đặc điểm là:",
    "options": [
      "Hiển thị những thông tin liên quan đến Activity hiện tại...",
      "Hiển thị những thông tin liên quan đến một đối tượng View cụ thể, để kích hoạt menu này người dùng cần nhấn và giữ đối tượng View mà nó liên kết.",
      "Hiển thị những thông tin liên quan đến một đối tượng View cụ thể, để kích hoạt menu này người dùng chỉ cần nhấn vào đối tượng View...",
      "Hiển thị những thông tin liên quan đến ứng dụng..."
    ],
    "answer": 1
  },
  {
    "q": "Các bước để thực hiện một Intent ngầm (Implicit Intent) gồm:",
    "options": [
      "Bước 1: Định nghĩa dữ liệu kèm theo dưới dạng Uri; Bước 2: Khai báo một Intent với 1 Action cụ thể và Uri đã định nghĩa; Bước 3: Gọi hàm startActivity()...",
      "Bước 1: Khai báo một Intent với 1 Action cụ thể; Bước 2: Gọi hàm startActivity()...; Bước 3: Khai báo View cần thiết...",
      "Bước 1: Khai báo View cần thiết...; Bước 2: Khai báo một Intent...; Bước 3: Gọi hàm startActivity()...",
      "Bước 1: Khai báo một Intent với 1 Action cụ thể; Bước 2: Định nghĩa dữ liệu kèm theo dưới dạng Bundle..."
    ],
    "answer": 0
  },
  {
    "q": "Trong thiết bị di động, bộ nhớ trong và bộ nhớ ngoài được phân biệt như sau:",
    "options": [
      "Bộ nhớ trong là bộ nhớ RAM, bộ nhớ ngoài là bộ nhớ ROM.",
      "Bộ nhớ trong là bộ nhớ được gắn sẵn trong thiết bị, bộ nhớ ngoài là SDCard.",
      "Bộ nhớ trong gồm RAM và bộ nhớ được gắn sẵn trong thiết bị, bộ nhớ ngoài là SDCard.",
      "Bộ nhớ trong chỉ được dùng để lưu dữ liệu riêng của mỗi ứng dụng..."
    ],
    "answer": 1
  },
  {
    "q": "Tạo bảng: tên là Lop_CT274, gồm 7 cột: ID, MSSV, Họ_Tên, Email, Diem_KT, Điểm_Thi, Điểm_TH. Hãy viết chuỗi tạo bảng.",
    "options": [
      "String CreatetbSchool=\"create table Lop_CT274 (+”id integer primary key autoincrement”,+”MSSV” text,...",
      "String CreatetbSchool=\"create table Lop_CT274 (\"+\"id integer primary key autoincrement,\"+“MSSV text, \"+“Ho_Ten text, \"+“Email text, \"+“Diem_KT float, \"+“Diem_Thi float, \"+“Diem_TH float)\");",
      "String CreatetbSchool=\"table Lop_CT274 (\"+\"id integer key autoincrement,\"+...",
      "Các câu khác với câu này đều sai."
    ],
    "answer": 1
  },
  {
    "q": "Đối tượng Preferences thường dùng để lưu trữ, điều chỉnh và phục hồi nội dung gì?",
    "options": [
      "Tập các tính năng của ứng dụng được người dùng tuỳ chọn.",
      "Các thiết lập của người dùng trong một ứng dụng.",
      "Tập các hoạt động của ứng dụng được người dùng tuỳ chọn.",
      "Tất cả A, B, C đều đúng."
    ],
    "answer": 3
  },
  {
    "q": "Các đối tượng được dùng để xây dựng thiết lập trong Android gồm:",
    "options": [
      "ListboxPreference; ViewPreference; FramePreference.",
      "CheckBoxPreference; ListPreference; EditTextPreference.",
      "PreferenceFragment; PreferenceActivity.",
      "Tất cả A, B và C đều sai."
    ],
    "answer": 1
  },
  {
    "q": "Quá trình phát triển của mạng viễn thông di động trải qua các thế hệ 1G, 2G, 3G, 4G, 5G. Sự chuyển đổi từ kỹ thuật tương tự (analog) sang kỹ thuật số (digital) diễn ra trong thế hệ nào?",
    "options": ["Áp dụng kỹ thuật số ngay từ đầu.", "3G", "4G", "2G"],
    "answer": 3
  },
  {
    "q": "Phân biệt mạng Piconet và Scatternet trong kỹ thuật Bluetooth",
    "options": [
      "Scatternet là mạng liên kết các thiết bị cùng cấp, Piconet là mạng liên kết giữa các Scatternet.",
      "Piconet là mạng liên kết các thiết bị cùng cấp, Scatternet là mạng liên kết giữa các Piconet.",
      "Piconet là mạng liên kết các thiết bị cùng loại, Scatternet là mạng liên kết giữa các thiết bị khác loại.",
      "Piconet là mạng liên kết các thiết bị khác loại, Scatternet là mạng liên kết giữa các thiết bị cùng loại."
    ],
    "answer": 1
  },
  {
    "q": "Điện thoại Android đầu tiên tên gì? Ra mắt năm nào?",
    "options": ["T-Mobile G1 – 1, 2008", "Nexus – one, 2008", "T-Mobile G1 – 1, 2007", "HTC One, 2008"],
    "answer": 0
  },
  {
    "q": "Các bước lập trình xử lý tương tác của người dùng lên các View như sau:",
    "options": [
      "Khai báo View → findViewById → setOnClickListener() + onClick().",
      "Khai báo View → Tạo phương thức ptTuongtac → android:onClick=”ptTuongtac”.",
      "Các câu trả lời A và B đều đúng.",
      "Câu trả lời A đúng và câu trả lời B sai."
    ],
    "answer": 2
  },
  {
    "q": "Các bước để thực hiện một Intent ngầm (Implicit Intent) gồm:",
    "options": [
      "Bước 1: Định nghĩa Uri → Bước 2: Intent + Action + Uri → Bước 3: startActivity()",
      "Bước 1: Intent + Action → Bước 2: startActivity() → Bước 3: Khai báo View",
      "Bước 1: Khai báo View → Bước 2: Intent + Action → Bước 3: startActivity()",
      "Bước 1: Intent + Action → Bước 2: Bundle → Bước 3: startActivity()"
    ],
    "answer": 0
  },
  {
    "q": "Context Menu có chức năng và đặc điểm là:",
    "options": [
      "Menu liên quan đến Activity hiện tại, góc phải trên, nhấn biểu tượng.",
      "Menu liên quan đến ứng dụng, góc phải trên tất cả Activity.",
      "Nhấn ngắn vào View để hiện.",
      "Nhấn và giữ vào View để hiện."
    ],
    "answer": 3
  },
  {
    "q": "Trong thiết bị di động, bộ nhớ trong và bộ nhớ ngoài được phân biệt như sau:",
    "options": [
      "Bộ nhớ trong là RAM, bộ nhớ ngoài là ROM.",
      "Bộ nhớ trong là bộ nhớ gắn sẵn, bộ nhớ ngoài là SDCard.",
      "Bộ nhớ trong chỉ lưu dữ liệu riêng app, bộ nhớ ngoài lưu chung.",
      "Bộ nhớ trong gồm RAM + gắn sẵn, bộ nhớ ngoài là SDCard."
    ],
    "answer": 1
  },
  {
    "q": "Đối tượng Preferences thường dùng để lưu trữ gì?",
    "options": [
      "Tập các tính năng của ứng dụng được người dùng tùy chọn.",
      "Các thiết lập của người dùng trong một ứng dụng.",
      "Tập các hoạt động của ứng dụng được người dùng tùy chọn.",
      "Tất cả A, B, C đều đúng."
    ],
    "answer": 3
  },
  {
    "q": "Các đối tượng được dùng để xây dựng thiết lập trong Android gồm:",
    "options": [
      "ListboxPreference; ViewPreference; FramePreference.",
      "CheckBoxPreference; ListPreference; EditTextPreference.",
      "PreferenceFragment; PreferenceActivity.",
      "Tất cả A, B và C đều sai."
    ],
    "answer": 1
  },
  {
    "q": "Tạo bảng Lop_CT274, viết chuỗi tạo bảng đúng:",
    "options": [
      "String CreatetbSchool=\"create table Lop_CT274 (\"+\"id integer primary key autoincrement,\"+\"MSSV text, \"+...+\")\";",
      "String CreatetbSchool=\"create table Lop_CT274 (+”id integer primary key autoincrement”,+”MSSV” text,...",
      "String CreatetbSchool=\"table Lop_CT274 (\"+\"id integer key autoincrement,\"+...",
      "Các câu khác với câu này đều sai."
    ],
    "answer": 0
  },
  {
    "q": "Để thao tác với cơ sở dữ liệu SQLite trên Android ta sử dụng các đối tượng nào?",
    "options": [
      "SQLiteOpenController và SQLiteDatabase",
      "SQLiteOpenHelper và SQLiteDatabase",
      "SQLiteData và SQLiteOpenManager",
      "SQLiteOpenHelper và SQLiteDataContent"
    ],
    "answer": 1
  },
  {
    "q": "Để xóa bảng trong SQLite, dùng phương thức:",
    "options": [
      "db.deleteDatabase(<tên Bảng>)",
      "db.execSQL(“DROP TABLE IF EXISTS ten_bang”)",
      "db.delete(“Tên bảng”)",
      "db.deleteTable(<tên Bảng>)"
    ],
    "answer": 1
  },
  {
    "q": "Khi sử dụng LinearLayout cần khai báo thêm thuộc tính gì?",
    "options": [
      "android:layout_gravity",
      "android:orientation",
      "Không bắt buộc",
      "android:layout_width và android:layout_height"
    ],
    "answer": 1
  },
  {
    "q": "Phiên bản Android mới nhất (08/2023) có các tên đại diện:",
    "options": [
      "Release number = 14, Target name = S, API = 34",
      "Version number = 12.0, Target name = S, API = 31",
      "Target = 13, Release name = Tiramisu, API = 33",
      "Target = 12L, Release name = Sv2, API = 32"
    ],
    "answer": 2
  },
  {
    "q": "Kiến trúc Android gồm các tầng:",
    "options": [
      "Linux Kernel; Application Framework; Virtual machine; Applications.",
      "Linux Kernel; Library; Android runtime; Application Framework; Applications.",
      "Unix Kernel; Library; Android runtime; Applications.",
      "Linux Kernel; Library - Android runtime; Application Framework; Applications."
    ],
    "answer": 3
  },
  {
    "q": "Tính năng mở của Android có nghĩa là:",
    "options": [
      "Mã nguồn mở.",
      "Không tốn phí môi trường phát triển.",
      "Chạy thử trực tiếp trên máy thật.",
      "Tất cả A, B và C đều đúng."
    ],
    "answer": 3
  },
  {
    "q": "4 thành phần chính của ứng dụng Android (phải khai báo trong Manifest):",
    "options": [
      "Activity, Service, Intent, Content Provider",
      "Activity, Service, Broadcast Receiver, Intent",
      "Activity, Service, Broadcast Receiver, Content Provider",
      "Activity, Intent, Broadcast Receiver, Content Provider"
    ],
    "answer": 2
  },
  {
    "q": "Hiện nay có bao nhiêu cách phát triển ứng dụng di động? Cách cơ bản nhất là gì?",
    "options": [
      "5 cách – Native platform là cơ bản nhất.",
      "4 cách – Cross platform là cơ bản nhất.",
      "5 cách – lập trình nhúng là cơ bản nhất.",
      "4 cách – Hybrid Apps là cơ bản nhất."
    ],
    "answer": 0
  },
  {
    "q": "Khái niệm abstraction trong lập trình gồm:",
    "options": [
      "Những môi trường phát triển phần mềm (SDE).",
      "Phần mềm nằm giữa phần cứng và môi trường phát triển: menu, database, file systems, API,…",
      "Máy ảo (Emulator).",
      "Lớp abstract không tạo được đối tượng."
    ],
    "answer": 1
  },
  {
    "q": "IDE là:",
    "options": [
      "Hệ điều hành/máy ảo cho viết 1 lần chạy nhiều nơi.",
      "Tổng thể phần cứng + phần mềm cung cấp công cụ phát triển.",
      "Môi trường hỗ trợ nhiều ngôn ngữ, biên dịch sang bytecode, chỉ chạy trên 1 HĐH.",
      "Phần mềm cung cấp toàn bộ phương tiện để lập trình viên phát triển ứng dụng trên 1 hoặc nhiều nền tảng."
    ],
    "answer": 3
  },
  {
    "q": "Kiến trúc Thin-Client Wireless Client-Server là:",
    "options": [
      "Client thực thi một phần, server một phần → không cần mạng liên tục.",
      "Truyền thông theo TCP/IP.",
      "Server thực hiện toàn bộ ứng dụng → client phải luôn kết nối mạng.",
      "Truyền thông theo UDP."
    ],
    "answer": 0
  },
  {
    "q": "Ứng dụng lai (Hybrid application) là:",
    "options": [
      "Chạy trên web, lập trình trên môi trường chạy nhiều nền tảng.",
      "Chạy đồng thời PC, smartphone, tablet.",
      "Chạy đồng thời PC, smartphone, tablet và mobile web.",
      "Lập trình 1 lần → chạy nhiều nền tảng."
    ],
    "answer": 2
  },
  {
    "q": "Khó khăn khi phát triển native iOS:",
    "options": [
      "Ngôn ngữ phức tạp.",
      "Tốn phí đăng ký developer, thiết bị thật, App Store.",
      "Chỉ cài được trên MacOS 10.6.8 trở lên.",
      "Tất cả A, B và C đều đúng."
    ],
    "answer": 3
  },
  {
    "q": "Explicit Intent là:",
    "options": [
      "Đã chỉ rõ component sẽ nhận xử lý, dùng trong cùng app.",
      "Khai báo rõ action, data.",
      "Dùng để khởi chạy ứng dụng đã cài.",
      "Chỉ xác định hành động, không chỉ định component."
    ],
    "answer": 0
  },
  {
    "q": "Lập trình giao diện mức cao là:",
    "options": [
      "Tạo giao diện tùy biến bằng code tự viết View.",
      "Dùng Layout + View có sẵn trong SDK.",
      "Dùng công cụ kéo thả trong Android Studio.",
      "Viết code XML không dùng kéo thả."
    ],
    "answer": 1
  },
  {
    "q": "Để Activity hiển thị giao diện, dùng phương thức:",
    "options": [
      "setLayoutView(R.layout.giaodien);",
      "setIntentView(R.layout.giaodien);",
      "setContentLayout(R.layout.giaodien);",
      "setContentView(R.layout.giaodien);"
    ],
    "answer": 3
  },
  {
    "q": "ImageView: lưu ảnh ở đâu và thuộc tính bắt buộc trong XML?",
    "options": [
      "res/drawable + android:src=\"@drawable/ten_anh\"",
      "res/layout + android:contentDescription",
      "res/mipmap + android:src",
      "Tất cả sai"
    ],
    "answer": 0
  },
  {
    "q": "Cách ánh xạ View từ XML sang Java:",
    "options": [
      "setContentView(R.id.xxx)",
      "findViewById(R.id.xxx)",
      "getViewById(R.layout.xxx)",
      "Tất cả sai"
    ],
    "answer": 1
  },
  {
    "q": "RadioGroup cho phép:",
    "options": [
      "Check nhiều RadioButton cùng lúc.",
      "Check một thì tất cả đều check.",
      "Chỉ check được một RadioButton trong nhóm.",
      "Tùy thuộc thuộc tính check."
    ],
    "answer": 2
  },
  {
    "q": "Activity trong ứng dụng Android:",
    "options": [
      "Mỗi app phải có Activity.",
      "Mỗi Activity = 1 màn hình.",
      "App có thể có 1 hoặc nhiều Activity.",
      "Tất cả đều đúng."
    ],
    "answer": 3
  },
  {
    "q": "Vai trò số hiệu cổng và địa chỉ IP:",
    "options": [
      "Cặp cổng+IP xác định server/client.",
      "Cổng xác định đường truyền, IP xác định thiết bị.",
      "IP phân biệt thiết bị, cổng phân biệt các process trên cùng máy.",
      "Luôn bắt buộc khai báo cho cả client/server."
    ],
    "answer": 2
  },
  {
    "q": "Khi mở project mới cần khai báo bao nhiêu phiên bản Android?",
    "options": [
      "3 phiên bản: compileSDK (mới nhất), minSDK, targetSDK (trung gian).",
      "Từ 3 phiên bản trở lên.",
      "2 phiên bản: compileSDK + minSDK.",
      "Chỉ 1 phiên bản mới nhất."
    ],
    "answer": 2
  },
  {
    "q": "Kết hợp giao diện mức cao và mức thấp:",
    "options": [
      "Mức cao lồng mức thấp.",
      "Mức thấp lồng mức cao.",
      "Activity mức thấp gọi Activity mức cao và ngược lại.",
      "Tất cả đều đúng."
    ],
    "answer": 3
  },
  {
    "q": "URI để truy vấn Contacts Content Provider:",
    "options": [
      "content://contacts/people",
      "provider://contacts/people",
      "contentprovider://contacts/people",
      "provider://content/contacts/people"
    ],
    "answer": 0
  },
  {
    "q": "Đọc tin nhắn inbox dùng:",
    "options": [
      "getSmsContent().query(...",
      "getContent().query(...",
      "getContent().getquery(...",
      "getContentResolver().query(Telephony.Sms.Inbox.CONTENT_URI, ..."
    ],
    "answer": 3
  },
  {
    "q": "Yêu cầu GET trong HTTP:",
    "options": [
      "Dữ liệu trong URL, dùng để gửi dữ liệu, mặc định.",
      "Dữ liệu trong luồng riêng, dùng để gửi dữ liệu.",
      "Dữ liệu trong URL, dùng để lấy dữ liệu, mặc định.",
      "URL + dữ liệu cùng luồng, gửi và nhận."
    ],
    "answer": 2
  },
  {
    "q": "Khi nào cần lập trình kết nối mạng cho app di động?",
    "options": [
      "Luôn luôn phải có.",
      "Khi app có chức năng cần kết nối mạng.",
      "Không cần vì thiết bị đã có sẵn.",
      "Luôn phải có để chạy thử."
    ],
    "answer": 1
  },
  {
    "q": "Cấu trúc JSON đúng:",
    "options": [
      "Chỉ có JSONObject {}",
      "Chỉ có JSONArray []",
      "JObject có JArray, dùng Name/Value.",
      "JSONArray [] và JSONObject {}, dùng Key/Value pairs."
    ],
    "answer": 3
  },
  {
    "q": "Mở kết nối HTTP dùng lớp và cú pháp:",
    "options": [
      "HttpConnection + getConnection()",
      "URLConnection + openConnection()",
      "ConnectionUrl + urlConnection()",
      "Tất cả sai"
    ],
    "answer": 1
  },
  {
    "q": "Kiểm tra tình trạng kết nối mạng – đáp án đúng:",
    "options": [
      "ConnectivitySystem + NetInfo + sai chính tả",
      "ConnectivityNetwork + getService + sai chính tả",
      "ConnectivityActive + getSystemService + sai chính tả",
      "Tất cả A, B và C đều sai."
    ],
    "answer": 3
  },
  {
    "q": "Để lập trình phát triển ứng dụng trên nền tảng gốc iOS, người lập trình gặp khó khăn gì?",
    "options": [
      "Ngôn ngữ lập trình được đánh giá là phức tạp.",
      "Tốn chi phí để đăng tuyển vào chương trình người phát triển iOS (tải SDK, cài đặt môi trường phát triển, kiểm thử trên thiết bị thật, đưa lên App Store).",
      "Môi trường phát triển ứng dụng iOS chỉ có thể cài đặt trên máy tính chạy hệ điều hành MacOS, (Macintosh, Hackintosh), version 10.6.8 trở lên.",
      "Tất cả A, B và C đều đúng."
    ],
    "answer": 3
  },
  {
    "q": "Để vẽ một đối tượng chuyển động ta có thể áp dụng nguyên tắc là làm thay đổi toạ độ của nó và vẽ lại đối tượng một cách liên tục với các toạ độ mới. Android cung cấp 1 phương thức để vẽ lại 1 đối tượng là:",
    "options": [
      "validate();",
      "redraw();",
      "invalidate();",
      "Các câu khác với câu này đều sai."
    ],
    "answer": 2
  },
  {
    "q": "Kiến trúc Thick-Client Wireless Client-Server là:",
    "options": [
      "Kiến trúc mà khi client truyền thông với server, nó có thể thực thi vài việc và server thực hiện các việc khác. Vì vậy không cần kết nối mạng liên tục và ổn định.",
      "Kiến trúc truyền thông theo giao thức TCP/IP.",
      "Kiến trúc này ứng dụng được thực hiện bởi server. Vì vậy đòi hỏi client phải kết nối mạng liên tục và ổn định, tương ứng với tập các đặc tính kỹ thuật chung nhỏ nhất của các thiết bị và platform.",
      "Kiến trúc truyền thông theo giao thức UDP."
    ],
    "answer": 0
  },
  {
    "q": "Ngoài vẽ những hình ảnh đơn giản còn có thể vẽ những hình ảnh có sẵn. Android hỗ trợ hình ảnh định dạng PNG, để sử dụng chỉ cần chép vào thư mục drawable là chương trình có thể gọi. Ta có thể dùng câu lệnh như thế nào? Trong các câu trả lời, “tên” là tên ảnh png đã lưu trong thư mục drawable và được gọi.",
    "options": [
      "Bitmap bitmap = BitmapFactory(getResources(),R.drawable.tên);",
      "Bitmap bitmap = BitmapFactory.decodeResource(getResources(),R.drawable.tên);",
      "Bitmap bitmap = Bitmap.decodeResource(getResources(),R.drawable.tên);",
      "Bitmap bitmap =decodeResource(getResources(),R.drawable.tên);"
    ],
    "answer": 1
  },
  {
    "q": "Trong Android có các cách lưu dữ liệu nào?",
    "options": [
      "Trong bộ nhớ trong, thẻ nhớ, trong tài khoản dịch vụ đám mây, dùng cơ sở dữ liệu SQLite, Content Provider.",
      "Bằng đối tượng Sharedpreferences, hoặc Hệ thống tập tin truyền thống, hoặc CSDL SQLite, hoặc Content Provider, hoặc định dạng XML hoặc JSON.",
      "Bằng tập tin XML, tập tin truyền thống, lập trình Java với SQLite, tài nguyên tĩnh, các thiết lập (setting), tập tin JSON.",
      "Trong bộ nhớ trong, thẻ nhớ, trong tài khoản dịch vụ đám mây, dùng cơ sở dữ liệu SQLite, Content Provider, các thiết lập tuỳ chỉnh, tài khoản trên server."
    ],
    "answer": 1
  },
  {
    "q": "Mỗi đối tượng Preference mà người lập trình thêm vào được lưu trữ dưới dạng nào?",
    "options": [
      "Một cặp name-value mà hệ thống dùng để lưu một thiết lập trong một tập tin SharePreferences mặc định.",
      "Một cặp key-data mà hệ thống dùng để lưu một thiết lập trong một tập tin XML mặc định.",
      "Một tập tin XML tương ứng với lớp SharePreferences.",
      "Một cặp key-value mà hệ thống dùng để lưu một thiết lập trong một tập tin SharePreferences mặc định."
    ],
    "answer": 3
  },
  {
    "q": "Trong chu kỳ sống (vòng đời) của ứng dụng: Ứng dụng chỉ được gọi là kết thúc khi nào?",
    "options": [
      "Khi tất cả các Activity trong ứng dụng kết thúc.",
      "Khi gọi phương thức onDestroy().",
      "Khi tất cả các Activity và các thành phần chạy ngầm khác trong ứng dụng kết thúc.",
      "Khi gọi phương thức onDestroy() và sau đó là phương thức finish()."
    ],
    "answer": 2
  },
  {
    "q": "Android có nhiều Content Provider hữu dụng được dựng sẵn như Browser, CallLog, Contacts, MediaStore, Settings. Để truy vấn một Content Provider, chẳng hạn như lấy tất cả các contacts từ một Contacts content provider, chúng ta khai báo như sau:",
    "options": [
      "content://contacts/people",
      "provider://contacts/people",
      "contentprovider://contacts/people",
      "provider://conent/contacts/people"
    ],
    "answer": 0
  },
  {
    "q": "Dữ liệu SQLite được xây dựng trên một ứng dụng Android có đặc điểm như sau:",
    "options": [
      "Có thể truy vấn bởi các ứng dụng khác.",
      "Là dữ liệu dùng riêng cho ứng dụng, chỉ có thể truy vấn bởi ứng dụng đó.",
      "Một phiên bản CSDL có thể dùng cho nhiều phiên bản ứng dụng.",
      "Khi nâng cấp ứng dụng lên phiên bản mới ta không cần thiết phải khai báo phiên bản CSDL mới."
    ],
    "answer": 1
  },
  {
    "q": "Content Provider lưu dữ liệu bằng hình thức nào?",
    "options": [
      "Chỉ lưu bằng tập tin XML hoặc JSON với các cặp khoá-giá trị.",
      "Có thể sử dụng nhiều cách khác nhau để lưu dữ, dữ liệu có thể được lưu giữ trong một cơ sở dữ liệu, một file,…",
      "Chỉ lưu dưới dạng tập tin.",
      "Chỉ lưu dưới dạng cơ sở dữ liệu SQLite."
    ],
    "answer": 1
  },
  {
    "q": "Trong giao thức HTTP, đáp ứng máy chủ gồm các thành phần nào và giải thích?",
    "options": [
      "Gồm 3 thành phần là: dòng trạng thái chỉ ra kết quả của yêu cầu; header chỉ ra thuộc tính của đáp ứng dùng để thông dịch nội dung và body chứa nội dung của đáp ứng.",
      "Gồm 2 thành phần là: dòng trạng thái chỉ ra kết quả của yêu cầu, thuộc tính của đáp ứng dùng để thông dịch nội dung và body chứa nội dung của đáp ứng.",
      "Gồm 4 thành phần là: dòng trạng thái chỉ ra kết quả của yêu cầu; header chỉ ra thuộc tính của đáp ứng dùng để thông dịch nội dung; body chứa nội dung của đáp ứng; footer báo kết thúc đáp ứng.",
      "Gồm 3 thành phần là: header chỉ ra kết quả của yêu cầu và thuộc tính của đáp ứng dùng để thông dịch nội dung, title trình bày tựa đề của đáp ứng và body chứa nội dung của đáp ứng."
    ],
    "answer": 0
  },
  {
    "q": "Phương thức sendDataMessage được dùng khi nào? Các đối số không null.",
    "options": [
      "Gởi dữ liệu bằng tin nhắn SMS, public void sendDataMessage (destinationAddress, null, short destinationPort, byte[] data, null, null)",
      "Gởi dữ liệu bằng tin nhắn MMS, public void sendDataMessage (destinationAddress, scAddress, null, byte[] data, null, null)",
      "Gởi dữ liệu bằng tin nhắn SMS, public void sendDataMessage (destinationAddress, scAddress, short destinationPort, byte[] data, null, null)",
      "Tất cả các câu trả lời khác đều sai."
    ],
    "answer": 2
  },
  {
    "q": "Để xây dựng chương trình nhận tin nhắn, chương trình bao gồm một danh sách hiển thị tất cả tin nhắn trong Inbox, ta sử dụng lớp nào?",
    "options": [
      "ListView",
      "ListArray",
      "ArrayAdaptor",
      "ListActivity"
    ],
    "answer": 3
  },
  {
    "q": "Trong URL sau: http://localhost:8080/myApp?first=joe&last=cool, hãy chọn câu giải thích đúng.",
    "options": [
      "http là giao thức; localhost là host; 8080 là port; /myApp?first=joe&last=cool là tập tin",
      "http là giao thức; localhost là host; 8080 là port; /myApp là tập tin; first=joe&last=cool là các cặp « khóa-giá trị » của yêu cầu.",
      "http là giao thức; localhost là host; 8080 là port; /myApp là tập tin; first=joe&last=cool là các thành phần tham khảo.",
      "http là giao thức; localhost là host; 8080 là địa chỉ; /myApp là thư mục; first=joe&last=cool các tập tin."
    ],
    "answer": 1
  },
  {
    "q": "Lớp JSONObject có chức năng gì?",
    "options": [
      "Tạo ra một đối tượng JSON tổng quát.",
      "Lấy một đối tượng JSON ở dạng Object.",
      "Tạo ra đối tượng quản lý JSON ở dạng một Object.",
      "Lấy một đối tượng JSON như một biến."
    ],
    "answer": 0
  },
  {
    "q": "Để có thể thực hiện các cuộc giao tiếp, một trong hai quá trình phải công bố số hiệu cổng của socket mà mình sử dụng. Ngoài số hiệu cổng, hai bên giao tiếp còn phải biết địa chỉ IP của nhau. Cho biết vai trò của số hiệu cổng và địa chỉ IP.",
    "options": [
      "Số hiệu cổng và IP là một cặp để xác định server hoặc client.",
      "Địa chỉ IP giúp phân biệt các thiết bị trên mạng TCP/IP. Trong khi số hiệu cổng dùng để phân biệt các quá trình khác nhau trên cùng một máy tính.",
      "Cổng đề xác định đường truyền, địa chỉ IP để xác định thiết bị trên mạng TCP/IP.",
      "Số hiệu cổng và địa chỉ IP đều bắt buộc khai báo trong mọi trường hợp cho cả client và server."
    ],
    "answer": 1
  },
  {
    "q": "Dùng Intent tường minh (Explicit Intent) để gọi 1 Activity khác từ 1 Activity trong cùng ứng dụng, ta dùng phương thức nào để gởi kèm theo dữ liệu:",
    "options": [
      "putIntent()",
      "putDataIIntent()",
      "pushExtra()",
      "putExtra()"
    ],
    "answer": 3
  },
  {
    "q": "Để thao tác với cơ sở dữ liệu lưu trữ trên SQLite trên Android ta sử dụng các đối tượng nào?",
    "options": [
      "SQLiteOpenController và SQLiteDatabase",
      "SQLiteOpenHelper và SQLiteDatabase",
      "SQLiteData và SQLiteOpenManager",
      "SQLiteOpenHelper và SQLiteDataContent"
    ],
    "answer": 1
  },
  {
    "q": "Các phương thức sau đây sẽ giúp lấy chiều rộng và chiều cao của canvas:",
    "options": [
      "getWidthCanvas() và getHeightCanvas()",
      "setWidth() và setHeight()",
      "getCanvasWidth() và getCanvasHeight()",
      "getWidth() và getHeight()"
    ],
    "answer": 3
  },
  {
    "q": "Khi sử dụng ListView kết hợp với lớp ListActivity, trong tập tin Layout, phần tử ListView phải khai báo id như sau:",
    "options": [
      "android:id=\"@+id/list\"",
      "android:id=\"@android:id/list\"",
      "android:id=\"@listactivity:id/list\"",
      "Các câu khác với câu này đều sai."
    ],
    "answer": 1
  },
  {
    "q": "Tạo sao khi khai báo thuộc tính text cho một View, người ta khuyên nên khai báo định danh của text sau đó khai báo String của text trong tập tin strings.xml?",
    "options": [
      "Vì khai báo text trong tập tin string.xml hỗ trợ cho việc chuẩn bị sẵn nhiều text để dễ dàng thay đổi text khi cần thiết.",
      "Vì khai báo text trong tập tin string.xml sẽ ít bị lỗi trùng text khi có nhiều View cần khai báo thuộc tính text.",
      "Vì khai báo text trong tập tin string.xml hỗ trợ cho việc thiết kế giao diện đa ngôn ngữ và dễ dàng thay đổi text khi cần thiết.",
      "Tất cả các câu trả lời đều đúng."
    ],
    "answer": 2
  },
  {
    "q": "Khi dùng explicit intent để từ Activity hiện tại gọi một Activity khác, ta cần phải viết lệnh nào?",
    "options": [
      "Intent intent = new Intent(this, NextActivity.class); startActivity(intent);",
      "Intent intent = new Intent(); startActivity(intent, NextActivity.class);",
      "Intent intent = new Intent(NextActivity.class); startActivity(intent);",
      "Intent intent = new Intent(this); startActivity(intent, NextActivity.class);"
    ],
    "answer": 0
  },
  {
    "q": "Trong Android, để Activity (giả sử viết bằng ngôn ngữ Java) hiển thị một giao diện ta sử dụng phương thức và câu lệnh như sau (Giả sử “giaodien” là tên giao diện được chọn để hiển thị):",
    "options": [
      "setLayoutView(R.layout.giaodien);",
      "setIntentView(R.layout.giaodien);",
      "setContentView(R.layout.giaodien);",
      "setContentLayout(R.layout.giaodien);"
    ],
    "answer": 2
  },
  {
    "q": "Khi sử dụng LinearLayout cần phải khai báo thêm thuộc tính gì?",
    "options": [
      "Thuộc tính android:orientation.",
      "Thuộc tính android:layout_gravity.",
      "Không bắt buộc khai báo thêm.",
      "Thuộc tính android:layout_width và android:layout_height."
    ],
    "answer": 0
  },
  {
    "q": "Các bước lập trình để kiểm tra tình trạng kết nối mạng:",
    "options": [
      "Bước 1: Tạo đối tượng ConnectivityHolder. Bước 2: getNetworkInfo(). Bước 3: getType(). Bước 4: Hiển thị.",
      "Bước 1: getconnectivityManager(). Bước 2: getActiveNetwork(). Bước 3: getTypeInfo(). Bước 4: Hiển thị.",
      "Bước 1: getconnectivityManager(). Bước 2: getActiveNetworkInfo(). Bước 3: Hiển thị.",
      "Bước 1: ConnectivityManager với getSystemService. Bước 2: getActiveNetworkInfo(). Bước 3: getType(). Bước 4: Hiển thị."
    ],
    "answer": 3
  },
  {
    "q": "Để xây dựng chương trình để nhận tin nhắn, chương trình chỉ bao gồm một danh sách hiển thị tất cả tin nhắn trong Inbox, ta sử dụng lớp nào?",
    "options": [
      "ListActivity",
      "InboxActivity",
      "Inbox",
      "ListView"
    ],
    "answer": 0
  },
  {
    "q": "Các bước thực hiện giao thức HTTP với phương thức GET như sau:",
    "options": [
      "Khởi tạo InputStream. Mở HTTP với URL. Thiết lập thuộc tính. Lấy HTTP_OK. Lấy InputStream.",
      "HttpClient. HttpGet. Thêm yêu cầu vào URL. Thiết lập kết nối và lấy đáp ứng.",
      "HttpGet. Lấy HTTP_OK. Lấy InputStream.",
      "Khởi tạo InputStream. Mở HTTP với URL. Lấy HTTP_OK. Lấy InputStream."
    ],
    "answer": 1
  },
  {
    "q": "Phân biệt các kiểu kết nối mạng HTTP và Socket?",
    "options": [
      "Socket ở Transport layer, HTTP ở Network Layer.",
      "Socket ở Transport layer, HTTP ở Application Layer.",
      "Socket ở Application layer, HTTP ở Network Layer.",
      "Socket ở Network layer, HTTP ở Application Layer."
    ],
    "answer": 1
  },
  {
    "q": "Giả sử một cơ sở dữ liệu SQLite tên là db có bảng dữ liệu tên là Lop_CK20 như sau: Hãy viết lệnh truy vấn các sinh viên có điểm tổng hợp (TH) trên 7 điểm và xếp theo thứ tự giảm dần.",
    "options": [
      "Cursor ds7 = db.query (Lop_CK20, String [] {ID, MSSV, KT, THI, TH}, TH”>7”, null, null, null, TH+”DESC”",
      "Cursor ds7 = db.query (Lop_CK20, String [] {MSSV, Ho_Ten, KT, THI, TH}, TH,”>7”, null, null, TH+”DESC”);",
      "Cursor ds7 = db.query (Lop_CK20, String [] {ID, MSSV, Ho_Ten, KT, THI, TH}, TH”>?”,”7”, null, null, TH+”DESC”);",
      "String[] ds7 = db.query (Lop_CK20, String [] {ID, MSSV, Ho_Ten, TH}, TH,”>7”, null, null, TH+”DESC”);"
    ],
    "answer": 2
  },
  {
    "q": "Visible process là tiến trình của ứng dụng mà:",
    "options": [
      "Activity đang hiển thị đối với người dùng trong thời gian phương thức onPause() được gọi mà sau đó chưa gọi phương thức nào khác.",
      "Activity đang hiển thị đối với người dùng từ lúc phương thức onCreate() được gọi đến phương thức onStop() hoặc onDestroy().",
      "Activity đang hiển thị đối với người dùng từ lúc phương thức onStart() của Activity được gọi đến phương thức onPause() hoặc onStop().",
      "Activity đang hiển thị đối với người dùng từ lúc phương thức onCreate() hoặc onResume() được gọi đến phương thức onStop() hoặc onDestroy()."
    ],
    "answer": 2
  },
  {
    "q": "Nền tảng Android ra mắt vào năm nào?",
    "options": [
      "2005",
      "2006",
      "2008",
      "2007"
    ],
    "answer": 3
  },
  {
    "q": "Máy ảo Java, JVM (Java Virtual Machine), là:",
    "options": [
      "Một phần mềm mô phỏng giúp thử nghiệm các ứng dụng trước khi cho chạy trên thiết bị thật.",
      "Bộ biên dịch mã bytecode, nó có nhiệm vụ chuyển mã bytecode của chương trình Java thành ngôn ngữ máy để chạy trên thiết bị di động.",
      "Bộ chuẩn hóa các chương trình Java cho các thiết bị di động khác nhau có thể có bộ vi xử lý và tập lệnh khác nhau.",
      "Tất cả các câu trả lời khác đều chưa đầy đủ hoặc không đúng."
    ],
    "answer": 1
  },
  {
    "q": "Trong dữ liệu SQLite, để thêm dữ liệu vào bảng ta thực hiện thủ tục gì?",
    "options": [
      "Khai báo 1 đối tượng InitialValues sau đó kết hợp với phương thức put để thêm dữ liệu vào các dòng cho từng cột.",
      "Khai báo 1 đối tượng ContentValues sau đó kết hợp với phương thức add để thêm dữ liệu vào các dòng cho từng cột.",
      "Khai báo 1 đối tượng ContentValues, kết hợp với phương thức put để thêm dữ liệu vào các dòng cho từng cột và sau đó dùng phương thức insert để cập nhật.",
      "Khai báo 1 đối tượng InitialValues, kết hợp với phương thức put để thêm dữ liệu vào các dòng cho từng cột và sau đó dùng phương thức update để cập nhật."
    ],
    "answer": 2
  },
  {
    "q": "Nền tảng (platform) là:",
    "options": [
      "Sự liên kết giữa cấu hình phần cứng, hệ điều hành, ngôn ngữ lập trình và các trừu tượng.",
      "Sự liên kết giữa hệ điều hành và các trừu tượng.",
      "Sự liên kết giữa cấu hình phần cứng và hệ điều hành.",
      "Sự liên kết giữa hệ điều hành, ngôn ngữ lập trình và các trừu tượng."
    ],
    "answer": 0
  },
  {
    "q": "Khung (Frameworks) là:",
    "options": [
      "Một bộ gồm platform, công cụ quản lý cần thiết, ngôn ngữ lập trình, các trừu tượng.",
      "Một bộ gồm môi trường phát triển tích hợp (IDE) và công cụ quản lý cần thiết.",
      "Một bộ gồm môi trường phát triển phần mềm (SDE) và công cụ quản lý cần thiết.",
      "Một môi trường tích hợp (IDE) trên một platform với các công cụ tương ứng."
    ],
    "answer": 1
  },
  {
    "q": "Để khắc phục khó khăn do đa nền tảng (nhà phát triển ứng dụng phải mất nhiều thời gian và công sức lập trình ứng dụng trên các môi trường và ngôn ngữ khác nhau cho các nền tảng khác nhau) người ta đã thực hiện giải pháp sau:",
    "options": [
      "Mã nguồn của ứng dụng được viết bằng một ngôn ngữ nhất định, sau đó được biên dịch sang mã ByteCode và chạy trên máy ảo trong thời gian thực.",
      "Phát triển các môi trường tích hợp chéo (Cross platform hoặc Cross framework).",
      "Phát triển các ứng dụng lai (Hybrid Apps) hoặc sử dụng các môi trường phát triển ứng dụng không cần code.",
      "Tất cả A, B và C đều đúng."
    ],
    "answer": 3
  },
  {
    "q": "Khi mở project mới ta cần khai báo chọn bao nhiêu phiên bản, những phiên bản nào? Tại sao?",
    "options": [
      "Cần khai báo 3 phiên bản: 1 để biên dịch (mới nhất, mặc định), 1 phiên bản cũ nhất có thể chạy được ứng dụng và 1 phiên bản trung gian để chạy thử ứng dụng.",
      "Cần khai báo từ 3 phiên bản trở lên: 1 để biên dịch (mới nhất), 1 phiên bản cũ nhất có thể chạy được ứng dụng và các phiên bản trung gian để chạy thử ứng dụng bằng máy ảo.",
      "Cần khai báo 2 phiên bản: 1 để biên dịch (mới nhất, mặc định), 1 phiên bản cũ nhất có thể chạy được ứng dụng.",
      "Cần khai báo 1 phiên bản mới nhất (mặc định)."
    ],
    "answer": 2
  },
  {
    "q": "Kiến trúc Android gồm các tầng nào?",
    "options": [
      "Gồm 5 tầng: Tầng Linux Kernel; Tầng Library; Tầng Android runtime; Tầng Application Framework; Tầng Applications.",
      "Gồm 4 tầng: Tầng Linux Kernel; Tầng Library và Android runtime; Tầng Application Framework; Tầng Applications.",
      "Gồm 3 tầng: Tầng Linux Kernel - Android runtime; Tầng Application Framework; Tầng Applications.",
      "Gồm 4 tầng: Tầng Linux Kernel - Android runtime; Tầng Library; Tầng Application Framework; Tầng Applications."
    ],
    "answer": 1
  },
  {
    "q": "Vai trò và cách tạo một Thread:",
    "options": [
      "Vai trò: sinh ra các tiến trình (luồng) cho một ứng dụng; Cách tạo: Khai báo một lớp kế thừa của lớp Thread và dùng phương thức start() để khởi động tiến trình.",
      "Vai trò: chỉ được dùng để sinh ra các tiến trình (luồng) khi có nhiều tiến trình chạy đồng thời trong một ứng dụng; Cách tạo: Khai báo một lớp kế thừa của lớp Thread và dùng phương thức setcurrent() để khởi động tiến trình.",
      "Vai trò: sinh ra các tiến trình (luồng) có thể chạy đồng thời trong một ứng dụng; Cách tạo: Khai báo một lớp kế thừa của lớp Thread và dùng phương thức run() để khởi động tiến trình",
      "Tất cả các câu trả lời khác với câu này đều sai."
    ],
    "answer": 0
  },
  {
    "q": "Android cung cấp thêm khả năng lập trình giao diện mức thấp để người lập trình có thể tự do vẽ bất cứ thứ gì mình muốn, để vẽ ta cần phải gọi bốn thành phần cơ bản:",
    "options": [
      "Đối tượng kiểu Image; đối tượng Canvas; đối tượng kiểu Bitmap và đối tượng Graphic.",
      "Đối tượng View; đối tượng Canvas; đối tượng kiểu Bitmap và đối tượng chứa nét vẽ cần vẽ ra (có thể là Rect, Path, Bitmap…).",
      "Đối tượng kiểu Paint; đối tượng SurfaceView; đối tượng kiểu Bitmap và đối tượng chứa nét vẽ cần vẽ ra (có thể là Rect, Path, Bitmap…).",
      "Đối tượng kiểu Paint; đối tượng Canvas; đối tượng kiểu Bitmap và đối tượng chứa nét vẽ cần vẽ ra (có thể là Rect, Path, Bitmap…)."
    ],
    "answer": 3
  },
  {
    "q": "Giả sử một cơ sở dữ liệu SQLite tên là db có bảng dữ liệu tên là Lop_CK20 như sau: Hãy viết lệnh truy vấn các sinh viên có điểm tổng hợp (TH) trên 7 điểm và xếp theo thứ tự giảm dần.",
    "options": [
      "Cursor ds7 = db.query (Lop_CK20, String [] {ID, MSSV, KT, THI, TH}, TH”>7”, null, null, null, TH+”DESC”",
      "Cursor ds7 = db.query (Lop_CK20, String [] {MSSV, Ho_Ten, KT, THI, TH}, TH,”>7”, null, null, TH+”DESC”);",
      "Cursor ds7 = db.query (Lop_CK20, String [] {ID, MSSV, Ho_Ten, KT, THI, TH}, TH”>?”,”7”, null, null, TH+”DESC”);",
      "String[] ds7 = db.query (Lop_CK20, String [] {ID, MSSV, Ho_Ten, TH}, TH,”>7”, null, null, TH+”DESC”);"
    ],
    "answer": 2
  },
  {
    "q": "Phương thức sendDataMessage được dùng khi nào? Các đối số không null.",
    "options": [
      "Gởi dữ liệu bằng tin nhắn SMS,public void sendDataMessage ( destinationAddress, null,short destinationPort,byte[] data, null, null)",
      "Gởi dữ liệu bằng tin nhắn MMS,public void sendDataMessage ( destinationAddress, scAddress, null, byte[] data, null, null)",
      "Gởi dữ liệu bằng tin nhắn SMS,public void sendDataMessage ( destinationAddress, scAddress, short destinationPort, byte[] data, null, null)",
      "Tất cả các câu trả lời khác đều sai."
    ],
    "answer": 2
  },
  {
    "q": "Để xây dựng chương trình nhận tin nhắn, chương trình bao gồm một danh sách hiển thị tất cả tin nhắn trong Inbox, ta sử dụng lớp nào?",
    "options": [
      "ListView",
      "ListArray",
      "ArrayAdaptor",
      "ListActivity"
    ],
    "answer": 3
  },
  {
    "q": "Lớp JSONObject có chức năng gì?",
    "options": [
      "Tạo ra một đối tượng JSON tổng quát.",
      "Lấy một đối tượng JSON ở dạng Object.",
      "Tạo ra đối tượng quản lý JSON ở dạng một Object.",
      "Lấy một đối tượng JSON như một biến."
    ],
    "answer": 0
  },
  {
    "q": "Kiến trúc Thick-Client Wireless Client-Server là:",
    "options": [
      "Kiến trúc mà khi client truyền thông với server, nó có thể thực thi vài việc và server thực hiện các việc khác. Vì vậy không cần kết nối mạng liên tục và ổn định.",
      "Kiến trúc truyền thông theo giao thức TCP/IP.",
      "Kiến trúc này ứng dụng được thực hiện bởi server. Vì vậy đòi hỏi client phải kết nối mạng liên tục và ổn định, tương ứng với tập các đặc tính kỹ thuật chung nhỏ nhất của các thiết bị và platform.",
      "Kiến trúc truyền thông theo giao thức UDP."
    ],
    "answer": 0
  },
  {
    "q": "Trong URL sau:, hãy chọn câu giải thích đúng.",
    "options": [
      "http là giao thức; localhost là host; 8080 là port ; /myApp?first=joe&last=cool là tập tin",
      "http là giao thức; localhost là host; 8080 là port ; /myApp là tập tin ; first=joe&last=cool là các cặp « khóa-giá trị » của yêu cầu.",
      "http là giao thức; localhost là host; 8080 là port ; /myApp là tập tin ; first=joe&last=cool là các thành phần tham khảo.",
      "http là giao thức; localhost là host ; 8080 là địa chỉ ; /myApp là thư mục ; first=joe&last=cool các tập tin."
    ],
    "answer": 1
  },
  {
    "q": "Ngoài vẽ những hình ảnh đơn giản còn có thể vẽ những hình ảnh có sẵn. Android hỗ trợ hình ảnh định dạng PNG, để sử dụng chỉ cần chép vào thư mục drawable là chương trình có thể gọi. Ta có thể dùng câu lệnh như thế nào? Trong các câu trả lời, \"tên\" là tên ảnh png đã lưu trong thư mục drawable và được gọi.",
    "options": [
      "Bitmap bitmap = BitmapFactory(getResources(),R.drawable.tên);",
      "Bitmap bitmap = BitmapFactory.decodeResource(getResources(),R.drawable.tên);",
      "Bitmap bitmap = Bitmap.decodeResource(getResources(),R.drawable.tên);",
      "Bitmap bitmap =decodeResource(getResources(),R.drawable.tên);"
    ],
    "answer": 1
  },
  {
    "q": "Trong Android có các cách lưu dữ liệu nào?",
    "options": [
      "Trong bộ nhớ trong, thẻ nhớ, trong tài khoản dịch vụ đám mây, dùng cơ sở dữ liệu SQLite, Content Provider.",
      "Bằng đối tượng Sharedpreferences , hoặc Hệ thống tập tin truyền thống, hoặc CSDL SQLite, hoặc Content Provider, hoặc định dạng XML hoặc JSON.",
      "Bằng tập tin XML, tập tin truyền thống, lập trình Java với SQLite, tài nguyên tĩnh, các thiết lập (setting), tập tin JSON.",
      "Trong bộ nhớ trong, thẻ nhớ, trong tài khoản dịch vụ đám mây, dùng cơ sở dữ liệu SQLite, Content Provider, các thiết lập tuỳ chỉnh, tài khoản trên server."
    ],
    "answer": 1
  },
  {
    "q": "Mỗi đối tượng Preference mà người lập trình thêm vào được lưu trữ dưới dạng nào?",
    "options": [
      "Một cặp name-value mà hệ thống dùng để lưu một thiết lập trong một tập tin SharePreferences mặc định.",
      "Một cặp key-data mà hệ thống dùng để lưu một thiết lập trong một tập tin XML mặc định.",
      "Một tập tin XML tương ứng với lớp SharePreferences.",
      "Một cặp key-value mà hệ thống dùng để lưu một thiết lập trong một tập tin SharePreferences mặc định."
    ],
    "answer": 3
  },
  {
    "q": "Trong giao thức HTTP, đáp ứng máy chủ gồm các thành phần nào và giải thích?",
    "options": [
      "Gồm 3 thành phần là : dòng trạng thái chỉ ra kết quả của yêu cầu; header chỉ ra thuộc tính của đáp ứng dùng để thông dịch nội dung và body chứa nội dung của đáp ứng.",
      "Gồm 2 thành phần là : dòng trạng thái chỉ ra kết quả của yêu cầu, thuộc tính của đáp ứng dùng để thông dịch nội dung và body chứa nội dung của đáp ứng.",
      "Gồm 4 thành phần là : dòng trạng thái chỉ ra kết quả của yêu cầu; header chỉ ra thuộc tính của đáp ứng dùng để thông dịch nội dung; body chứa nội dung của đáp ứng; footer báo kết thúc đáp ứng.",
      "Gồm 3 thành phần là : header chỉ ra kết quả của yêu cầu và thuộc tính của đáp ứng dùng để thông dịch nội dung , title trình bày tựa đề của đáp ứng và body chứa nội dung của đáp ứng."
    ],
    "answer": 0
  },
  {
    "q": "Trong chu kỳ sống (vòng đời) của ứng dụng: Ứng dụng chỉ được gọi là kết thúc khi nào?",
    "options": [
      "Khi tất cả các Activity trong ứng dụng kết thúc.",
      "Khi gọi phương thức onDetroy().",
      "Khi tất cả các Activity và các thành phần chạy ngầm khác trong ứng dụng kết thúc.",
      "Khi gọi phương thức onDetroy() và sau đó là phương thức finish()."
    ],
    "answer": 2
  },
  {
    "q": "Dùng Intent tường minh (Explicit Intent) để gọi 1 Activity khác từ 1 Activity trong cùng ứng dụng, ta dùng phương thức nào để gởi kèm theo dữ liệu:",
    "options": [
      "putIntent()",
      "putDataIIntent()",
      "pushExtra()",
      "putExtra ()"
    ],
    "answer": 3
  },
  {
    "q": "Android có nhiều Content Provider hữu ích được dựng sẵn như Browser, CallLog, Contacts, MediaStore, Settings. Để truy vấn một Content Provider, chẳng hạn như lấy tất cả các contacts từ một Contacts content provider, chúng ta khai báo như sau:",
    "options": [
      "content://contacts/people",
      "provider://contacts/people",
      "contentprovider://contacts/people",
      "provider://conent/contacts/people"
    ],
    "answer": 0
  },
  {
    "q": "Dữ liệu SQLite được xây dựng trên một ứng dụng Android có đặc điểm như sau:",
    "options": [
      "Có thể truy vấn bởi các ứng dụng khác.",
      "Là dữ liệu dùng riêng cho ứng dụng, chỉ có thể truy vấn bởi ứng dụng đó.",
      "Một phiên bản CSDL có thể dùng cho nhiều phiên bản ứng dụng.",
      "Khi nâng cấp ứng dụng lên phiên bản mới ta không cần thiết phải khai báo phiên bản CSDL mới."
    ],
    "answer": 1
  },
  {
    "q": "Content Provider lưu dữ liệu bằng hình thức nào?",
    "options": [
      "Chỉ lưu bằng tập tin XML hoặc JSON với các cặp khoá-giá trị.",
      "Có thể sử dụng nhiều cách khác nhau để lưu dữ, dữ liệu có thể được lưu giữ trong một cơ sở dữ liệu, một file,…",
      "Chỉ lưu dưới dạng tập tin.",
      "Chỉ lưu dưới dạng cơ sở dữ liệu SQLite."
    ],
    "answer": 1
  },
  {
    "q": "Để vẽ một đối tượng chuyển động ta có thể áp dụng nguyên tắc là làm thay đổi toạ độ của nó và vẽ lại đối tượng một cách liên tục với các toạ độ mới. Android cung cấp 1 phương thức để vẽ lại 1 đối tượng là:",
    "options": [
      "validate();",
      "redraw();",
      "invalidate();",
      "Các câu khác với câu này đều sai."
    ],
    "answer": 2
  },
  {
    "q": "Các phương thức sau đây sẽ giúp lấy chiều rộng và chiều cao của canvas:",
    "options": [
      "getWidthCanvas() và getHeightCanvas()",
      "setWidth() và setHeight()",
      "getCanvasWidth() và getCanvasHeight()",
      "getWidth() và getHeight()"
    ],
    "answer": 3
  },
  {
    "q": "Khi sử dụng ListView kết hợp với lớp ListActivity, trong tập tin Layout, phần tử ListView phải khai báo id như sau:",
    "options": [
      "android:id=\"@+id/list\"",
      "android:id=\"@android:id/list\"",
      "android:id=\"@listactivity:id/list\"",
      "Các câu khác với câu này đều sai."
    ],
    "answer": 1
  },
  {
    "q": "Tạo sao khi khai báo thuộc tính text cho một View, người ta khuyên nên khai báo định danh của text sau đó khai báo String của text trong tập tin strings.xml?",
    "options": [
      "Vì khai báo text trong tập tin string.xml hỗ trợ cho việc chuẩn bị sẵn nhiều text để dễ dàng thay đổi text khi cần thiết.",
      "Vì khai báo text trong tập tin string.xml sẽ ít bị lỗi trùng text khi có nhiều View cần khai báo thuộc tính text.",
      "Vì khai báo text trong tập tin string.xml hỗ trợ cho việc thiết kế giao diện đa ngôn ngữ và dễ dàng thay đổi text khi cần thiết.",
      "Tất cả các câu trả lời đều đúng."
    ],
    "answer": 2
  },
  {
    "q": "Khi dùng explicit intent để từ Activity hiện tại gọi một Activity khác, ta cần phải viết lệnh nào?",
    "options": [
      "Intent intent = new Intent(this, NextActivity.class); startActivity(intent);",
      "Intent intent = new Intent(); startActivity(intent, NextActivity.class);",
      "Intent intent = new Intent(NextActivity.class); startActivity(intent);",
      "Intent intent = new Intent(this); startActivity(intent, NextActivity.class);"
    ],
    "answer": 0
  },
  {
    "q": "Để lập trình phát triển ứng dụng trên nền tảng gốc iOS, người lập trình gặp khó khăn gì?",
    "options": [
      "Ngôn ngữ lập trình được đánh giá là phức tạp.",
      "Tốn chi phí để đăng tuyển vào chương trình người phát triển iOS (tải SDK, cài đặt môi trường phát triển, kiểm thử trên thiết bị thật, đưa lên App Store).",
      "Môi trường phát triển ứng dụng iOS chỉ có thể cài đặt trên máy tính chạy hệ điều hành MacOS, (Macintosh, Hackintosh), version 10.6.8 trở lên.",
      "Tất cả A, B và C đều đúng."
    ],
    "answer": 3
  },
  {
    "q": "Trong Android, để Activity (giả sử viết bằng ngôn ngữ Java) hiển thị một giao diện ta sử dụng phương thức và câu lệnh như sau (Giả sử “giaodien” là tên giao diện được chọn để hiển thị):",
    "options": [
      "setLayoutView(R.layout.giaodien);",
      "setIntentView(R.layout.giaodien);",
      "setContentView(R.layout.giaodien);",
      "setContentLayout(R.layout.giaodien);"
    ],
    "answer": 2
  },
  {
    "q": "Khi sử dụng LinearLayout cần phải khai báo thêm thuộc tính gì?",
    "options": [
      "Thuộc tính android:layout_gravity.",
      "Thuộc tính android:orientation.",
      "Không bắt buộc khai báo thêm.",
      "Thuộc tính android:layout_width và android:layout_height."
    ],
    "answer": 1
  },
  {
    "q": "Để xây dựng chương trình để nhận tin nhắn, chương trình chỉ bao gồm một danh sách hiển thị tất cả tin nhắn trong Inbox, ta sử dụng lớp nào?",
    "options": [
      "ListActivity",
      "InboxActivity",
      "Inbox",
      "ListView"
    ],
    "answer": 0
  },
  {
    "q": "Để có thể thực hiện các cuộc giao tiếp, một trong hai quá trình phải công bố số hiệu cổng của socket mà mình sử dụng. Ngoài số hiệu cổng, hai bên giao tiếp còn phải biết địa chỉ IP của nhau. Cho biết vai trò của số hiệu cổng và địa chỉ IP.",
    "options": [
      "Số hiệu cổng và IP là một cặp để xác định server hoặc client.",
      "Địa chỉ IP giúp phân biệt các thiết bị trên mạng TCP/IP. Trong khi số hiệu cổng dùng để phân biệt các quá trình khác nhau trên cùng một máy tính.",
      "Cổng đề xác định đường truyền, địa chỉ IP để xác định thiết bị trên mạng TCP/IP.",
      "Số hiệu cổng và địa chỉ IP đều bắt buộc khai báo trong mọi trường hợp cho cả client và server."
    ],
    "answer": 1
  },
  {
    "q": "Phân biệt các kiểu kết nối mạng HTTP và Socket?",
    "options": [
      "Socket là giao thức nằm ở tầng vận chuyển (Transport layer).   HTTP là giao thức nằm trong tầng mạng (Network Layer).",
      "Socket là giao thức nằm ở tầng vận chuyển (Transport layer). HTTP là giao thức nằm trong tầng ứng dụng (Application Layer).",
      "Socket là giao thức nằm ở tầng ứng dụng (Application layer. HTTP là giao thức nằm trong tầng mạng (Network Layer).",
      "Socket là giao thức nằm ở tầng mạng (Network layer). HTTP là giao thức nằm trong tầng ứng dụng (Application Layer)."
    ],
    "answer": 1
  },
  {
    "q": "Để thao tác với cơ sở dữ liệu lưu trữ trên SQLite trên Android ta sử dụng các đối tượng nào?",
    "options": [
      "SQLiteOpenController và SQLiteDatabase",
      "SQLiteOpenHelper và SQLiteDataContent",
      "SQLiteData và SQLiteOpenManager",
      "SQLiteOpenHelper và SQLiteDatabase"
    ],
    "answer": 3
  },
  {
    "q": "Trình bày các bước lập trình để kiểm tra xem điện thoại đang sử dụng loại kết nối nào?",
    "options": [
      "Bước 1:Tạo ra đối tượng quản lý kết nối với lớp ConnectivityHolder. Bước 2:Lấy biến thông tin về mạng với hàm getNetworkInfo(). Bước 3:Lấy thông tin về loại mạng đang kết nối với hàm getType().Bước 4: Viết các lệnh hiển thị thông tin kết nối mạng",
      "Bước 1:Tạo ra đối tượng kết nối với phương thức getconnectivityManager(). Bước 2: Lấy biến thông tin về mạng với hàm getAtiveNetwork(), Bước 3: Lấy thông tin về loại mạng đang kết nối với hàm getTypeInfo(). Bước 4: Viết các lệnh hiển thị thông tin kết nối mạng.",
      "Bước 1:Tạo ra đối tượng kết nối với phương thức getconnectivityManager(). Bước 2: Lấy biến thông tin về mạng với hàm getAtiveNetworkInfo(). Bước 3: Viết các lệnh hiển thị thông tin kết nối mạng.",
      "Bước 1:Tạo ra đối tượng ConnectivityManager với hàm getSystemService.Bước 2:Lấy biến thông tin về mạng với hàm getAtiveNetworkInfo(). Bước 3: Lấy thông tin về loại mạng đang kết nối với hàm getType(). Bước 4:Viết các lệnh hiển thị thông tin kết nối mạng."
    ],
    "answer": 3
  },
  {
    "q": "Các bước thực hiện giao thức HTTP với phương thức GET như sau:",
    "options": [
      "Khởi tạo một đối tượng InputSteam. Mở một kết nối HTTP với một URL từ xa.  Thiết lập các thuộc tính của kết nối. Lấy đáp ứng HTTP_OK để biết kết nối đã được thiết lập hay chưa. Nếu kết nối được thiết lập thì tiến hành lấy đối tượng InputStream từ kết nối để bắt đầu tải dữ liệu từ server.",
      "Tạo ra một đối tượng HttpClient. Tạo ra một đối tượng HttpGet.Thêm vào các yêu cầu vào URL. Thiết lập kết nối và lấy đáp ứng từ server.",
      "Tạo ra một đối tượng HttpGet. Lấy đáp ứng HTTP_OK để biết kết nối đã được thiết lập hay chưa.  Nếu kết nối được thiết lập thì tiến hành lấy đối tượng InputStream từ kết nối để bắt đầu tải dữ liệu từ server.",
      "Khởi tạo một đối tượng InputSteam. Mở một kết nối HTTP với một URL từ xa.Lấy đáp ứng HTTP_OK để biết kết nối đã được thiết lập hay chưa.Nếu kết nối được thiết lập thì tiến hành lấy đối tượng InputStream từ kết nối để bắt đầu tải dữ liệu từ server."
    ],
    "answer": 1
  },
  {
    "q": "Visible process là tiến trình của ứng dụng mà:",
    "options": [
      "Activity đang hiển thị đối với người dùng trong thời gian phương thức onPause() được gọi mà sau đó chưa gọi phương thức nào khác.",
      "Activity đang hiển thị đối với người dùng từ lúc phương thức onCreate() được gọi đến phương thức onStop() hoặc onDestroy().",
      "Activity đang hiển thị đối với người dùng từ lúc phương thức onStar() của Activity được gọi đến phương thức onPause() hoặc onStop().",
      "Activity đang hiển thị đối với người dùng từ lúc phương thức onCreate() hoặc onResume() được gọi đến phương thức onStop() hoặc onDestroy()."
    ],
    "answer": 2
  },
  {
    "q": "Nền tảng Android ra mắt vào năm nào?",
    "options": [
      "2005",
      "2006",
      "2008",
      "2007"
    ],
    "answer": 3
  },
  {
    "q": "Máy ảo Java, JVM (Java Virtual Machine), là:",
    "options": [
      "Một phần mềm mô phỏng giúp thử nghiệm các ứng dụng trước khi cho chạy trên thiết bị thật.",
      "Bộ biên dịch mã bytecode, nó có nhiệm vụ chuyển mã bytecode của chương trình Java thành ngôn ngữ máy để chạy trên thiết bị di động.",
      "Bộ chuẩn hóa các chương trình Java cho các thiết bị di động khác nhau có thể có bộ vi xử lý và tập lệnh khác nhau.",
      "Tất cả các câu trả lời khác đều chưa đầy đủ hoặc không đúng."
    ],
    "answer": 1
  },
  {
    "q": "Trong dữ liệu SQLite, để thêm dữ liệu vào bảng ta thực hiện thủ tục gì?",
    "options": [
      "Khai báo 1 đối tượng InitialValues sau đó kết hợp với phương thức put để thêm dữ liệu vào các dòng cho từng cột.",
      "Khai báo 1 đối tượng ContentValues sau đó kết hợp với phương thức add để thêm dữ liệu vào các dòng cho từng cột.",
      "Khai báo 1 đối tượng ContentValues, kết hợp với phương thức put để thêm dữ liệu vào các dòng cho từng cột và sau đó dùng phương thức insert để cập nhật.",
      "Khai báo 1 đối tượng InitialValues, kết hợp với phương thức put để thêm dữ liệu vào các dòng cho từng cột và sau đó dùng phương thức update để cập nhật."
    ],
    "answer": 2
  },
  {
    "q": "Nền tảng (platform) là:",
    "options": [
      "Sự liên kết giữa cấu hình phần cứng, hệ điều hành, ngôn ngữ lập trình và các trừu tượng.",
      "Sự liên kết giữa hệ điều hành và các trừu tượng.",
      "Sự liên kết giữa cấu hình phần cứng và hệ điều hành.",
      "Sự liên kết giữa hệ điều hành, ngôn ngữ lập trình và các trừu tượng."
    ],
    "answer": 0
  },
  {
    "q": "Khung (Frameworks) là:",
    "options": [
      "Một bộ gồm platform, công cụ quản lý cần thiết, ngôn ngữ lập trình, các trừu tượng.",
      "Một bộ gồm môi trường phát triển tích hợp (IDE) và công cụ quản lý cần thiết.",
      "Một bộ gồm môi trường phát triển phần mềm (SDE) và công cụ quản lý cần thiết.",
      "Một môi trường tích hợp (IDE) trên một platform với các công cụ tương ứng."
    ],
    "answer": 1
  },
  {
    "q": "Để khắc phục khó khăn do đa nền tảng (nhà phát triển ứng dụng phải mất nhiều thời gian và công sức lập trình ứng dụng trên các môi trường và ngôn ngữ khác nhau cho các nền tảng khác nhau) người ta đã thực hiện giải pháp sau:",
    "options": [
      "Mã nguồn của ứng dụng được viết bằng một ngôn ngữ nhất định, sau đó được biên dịch sang mã ByteCode và chạy trên máy ảo trong thời gian thực.",
      "Phát triển các môi trường tích hợp chéo (Cross platform hoặc Cross framework).",
      "Phát triển các ứng dụng lai (Hybrid Apps) hoặc sử dụng các môi trường phát triển ứng dụng không cần code.",
      "Tất cả A, B và C đều đúng."
    ],
    "answer": 3
  },
  {
    "q": "Kiến trúc Thick-Client Wireless Client-Server là:",
    "options": [
      "Kiến trúc truyền thông theo giao thức UDP.",
      "Kiến trúc truyền thông theo giao thức TCP/IP.",
      "Kiến trúc này ứng dụng được thực hiện bởi server. Vì vậy đòi hỏi client phải kết nối mạng liên tục và ổn định, tương ứng với tập các đặc tính kỹ thuật chung nhỏ nhất của các thiết bị và platform.",
      "Kiến trúc mà khi client truyền thông với server, nó có thể thực thi vài việc và server thực hiện các việc khác. Vì vậy không cần kết nối mạng liên tục và ổn định."
    ],
    "answer": 3
  },
  {
    "q": "Giả sử một cơ sở dữ liệu SQLite tên là db có bảng dữ liệu tên là Lop_CK20 như sau: Hãy viết lệnh truy vấn các sinh viên có điểm tổng hợp (TH) trên 7 điểm và xếp theo thứ tự giảm dần.",
    "options": [
      "Cursor ds7 =db.query (Lop_CK20, String [] {ID, MSSV, KT, THI, TH}, TH”>7”, null, null, null, TH+”DESC”",
      "Cursor ds7 =db.query (Lop_CK20, String [] {MSSV, Ho_Ten, KT, THI, TH}, TH,”>7”, null, null, TH+”DESC”);",
      "Cursor ds7 =db.query (Lop_CK20, String [] {ID, MSSV, Ho_Ten, KT, THI, TH}, TH”>?”,”7”, null, null, TH+”DESC”);",
      "String[] ds7 = db.query (Lop_CK20, String [] {ID, MSSV, Ho_Ten, TH}, TH,”>7”, null, null, TH+”DESC”);"
    ],
    "answer": 2
  },
  {
    "q": "Visible process là tiến trình của ứng dụng mà:",
    "options": [
      "Activity đang hiển thị đối với người dùng trong thời gian phương thức onPause() được gọi mà sau đó chưa gọi phương thức nào khác.",
      "Activity đang hiển thị đối với người dùng từ lúc phương thức onCreate() được gọi đến phương thức onStop() hoặc onDestroy().",
      "Activity đang hiển thị đối với người dùng từ lúc phương thức onStar() của Activity được gọi đến phương thức onPause() hoặc onStop().",
      "Activity đang hiển thị đối với người dùng từ lúc phương thức onCreate() hoặc onResume() được gọi đến phương thức onStop() hoặc onDestroy()."
    ],
    "answer": 2
  },
  {
    "q": "Nền tảng Android ra mắt vào năm nào?",
    "options": [
      "2005",
      "2006",
      "2007",
      "2008"
    ],
    "answer": 2
  },
  {
    "q": "Máy ảo Java, JVM (Java Virtual Machine), là:",
    "options": [
      "Một phần mềm mô phỏng giúp thử nghiệm các ứng dụng trước khi cho chạy trên thiết bị thật.",
      "Bộ biên dịch mã bytecode, nó có nhiệm vụ chuyển mã bytecode của chương trình Java thành ngôn ngữ máy để chạy trên thiết bị di động.",
      "Bộ chuẩn hóa các chương trình Java cho các thiết bị di động khác nhau có thể có bộ vi xử lý và tập lệnh khác nhau.",
      "Tất cả các câu trả lời khác đều chưa đầy đủ hoặc không đúng."
    ],
    "answer": 1
  },
  {
    "q": "Trong dữ liệu SQLite, để thêm dữ liệu vào bảng ta thực hiện thủ tục gì?",
    "options": [
      "Khai báo 1 đối tượng InitialValues sau đó kết hợp với phương thức put để thêm dữ liệu vào các dòng cho từng cột.",
      "Khai báo 1 đối tượng ContentValues sau đó kết hợp với phương thức add để thêm dữ liệu vào các dòng cho từng cột.",
      "Khai báo 1 đối tượng ContentValues, kết hợp với phương thức put để thêm dữ liệu vào các dòng cho từng cột và sau đó dùng phương thức insert để cập nhật.",
      "Khai báo 1 đối tượng InitialValues, kết hợp với phương thức put để thêm dữ liệu vào các dòng cho từng cột và sau đó dùng phương thức update để cập nhật."
    ],
    "answer": 2
  },
  {
    "q": "Nền tảng (platform) là:",
    "options": [
      "Sự liên kết giữa hệ điều hành và các trừu tượng.",
      "Sự liên kết giữa cấu hình phần cứng, hệ điều hành, ngôn ngữ lập trình và các trừu tượng.",
      "Sự liên kết giữa cấu hình phần cứng và hệ điều hành.",
      "Sự liên kết giữa hệ điều hành, ngôn ngữ lập trình và các trừu tượng."
    ],
    "answer": 1
  },
  {
    "q": "Khung (Frameworks) là:",
    "options": [
      "Một bộ gồm platform, công cụ quản lý cần thiết, ngôn ngữ lập trình, các trừu tượng.",
      "Một môi trường tích hợp (IDE) trên một platform với các công cụ tương ứng.",
      "Một bộ gồm môi trường phát triển phần mềm (SDE) và công cụ quản lý cần thiết.",
      "Một bộ gồm môi trường phát triển tích hợp (IDE) và công cụ quản lý cần thiết."
    ],
    "answer": 3
  },
  {
    "q": "Để khắc phục khó khăn do đa nền tảng (nhà phát triển ứng dụng phải mất nhiều thời gian và công sức lập trình ứng dụng trên các môi trường và ngôn ngữ khác nhau cho các nền tảng khác nhau) người ta đã thực hiện giải pháp sau:",
    "options": [
      "Mã nguồn của ứng dụng được viết bằng một ngôn ngữ nhất định, sau đó được biên dịch sang mã ByteCode và chạy trên máy ảo trong thời gian thực.",
      "Phát triển các môi trường tích hợp chéo (Cross platform hoặc Cross framework).",
      "Phát triển các ứng dụng lai (Hybrid Apps) hoặc sử dụng các môi trường phát triển ứng dụng không cần code.",
      "Tất cả các câu trả lời đều đúng."
    ],
    "answer": 3
  },
  {
    "q": "Khi mở project mới ta cần khai báo chọn bao nhiêu phiên bản, những phiên bản nào ? Tại sao ?",
    "options": [
      "Cần khai báo 3 phiên bản: 1 để biên dịch (mới nhất, mặc định), 1 phiên bản cũ nhất có thể chạy được ứng dụng và 1 phiên bản trung gian để chạy thử ứng dụng.",
      "Cần khai báo từ 3 phiên bản trở lên: 1 để biên dịch (mới nhất), 1 phiên bản cũ nhất có thể chạy được ứng dụng và các phiên bản trung gian để chạy thử ứng dụng bằng máy ảo.",
      "Cần khai báo 2 phiên bản: 1 để biên dịch (mới nhất, mặc định), 1 phiên bản cũ nhất có thể chạy được ứng dụng.",
      "Cần khai báo 1 phiên bản mới nhất (mặc định)."
    ],
    "answer": 2
  },
  {
    "q": "Kiến trúc Android gồm các tầng nào?",
    "options": [
      "Gồm 5 tầng:Tầng Linux Kernel; Tầng Library; Tầng Android runtime;Tầng Application Framework;Tầng Applications.",
      "Gồm 4 tầng:Tầng Linux Kernel; Tầng Library và Android runtime;Tầng Application Framework;Tầng Applications.",
      "Gồm 3 tầng:Tầng Linux Kernel - Android runtime;Tầng Application Framework;Tầng Applications.",
      "Gồm 4 tầng:Tầng Linux Kernel - Android runtime; Tầng Library;Tầng Application Framework;Tầng Applications."
    ],
    "answer": 1
  },
  {
    "q": "Vai trò và cách tạo một Thread:",
    "options": [
      "Vai trò: sinh ra các tiến trình (luồng) cho một ứng dụng; Cách tạo: Khai báo một lớp kế thừa của lớp Thread và dùng phương thức start() để khởi động tiến trình.",
      "Vai trò: chỉ được dùng để sinh ra các tiến trình (luồng) khi có nhiều tiến trình chạy đồng thời trong một ứng dụng; Cách tạo: Khai báo một lớp kế thừa của lớp Thread và dùng phương thức setcurrent() để khởi động tiến trình.",
      "Vai trò: sinh ra các tiến trình (luồng) có thể chạy đồng thời trong một ứng dụng; Cách tạo: Khai báo một lớp kế thừa của lớp Thread và dùng phương thức run() để khởi động tiến trình.",
      "Tất cả các câu trả lời khác với câu này đều sai."
    ],
    "answer": 0
  },
  {
    "q": "Android cung cấp thêm khả năng lập trình giao diện mức thấp để người lập trình có thể tự do vẽ bất cứ thứ gì mình muốn, để vẽ ta cần phải gọi bốn thành phần cơ bản:",
    "options": [
      "Đối tượng kiểu Image; đối tượng Canvas; đối tượng kiểu Bitmap và đối tượng Graphic.",
      "Đối tượng View; đối tượng Canvas; đối tượng kiểu Bitmap và đối tượng chứa nét vẽ cần vẽ ra (có thể là Rect, Path, Bitmap…).",
      "Đối tượng kiểu Paint; đối tượng SurfaceView; đối tượng kiểu Bitmap và đối tượng chứa nét vẽ cần vẽ ra (có thể là Rect, Path, Bitmap…).",
      "Đối tượng kiểu Paint; đối tượng Canvas; đối tượng kiểu Bitmap và đối tượng chứa nét vẽ cần vẽ ra (có thể là Rect, Path, Bitmap…)."
    ],
    "answer": 3
  },
  {
    "q": "Để xử lý các sự kiện touch trên View mức thấp ta phải làm gì?",
    "options": [
      "Phải ghi đè phương thức onTouchEvent(MotionEvent event) trong lớp View và return false.",
      "Phải ghi đè phương thức onTouchEvent(MotionEvent event) trong lớp View và return true.",
      "Phải ghi đè phương thức onTouch(MotionEvent event) trong lớp View và return true.",
      "Phải ghi đè phương thức onTouchEvent(MotionEvent event) trong lớp View và không cần return giá trị."
    ],
    "answer": 1
  },
  {
    "q": "Câu lệnh Java nào sau đây dùng để vẽ đường thẳng trên canvas? (Giả sử biến paint là đối tượng Paint, biến canvas là đối tượng Canvas, x1, y1, x2, y2 là các biến toạ độ kiểu float).",
    "options": [
      "paint.drawLine(x1, y1, x2, y2, canvas);",
      "canvas.drawLine(paint, x1, y1, x2, y2);",
      "canvas.drawLine(x1, y1, x2, y2, paint);",
      "paint.drawLine(canvas, x1, y1, x2, y2);"
    ],
    "answer": 2
  },
  {
    "q": "Câu lệnh Java nào sau đây dùng để vẽ Bitmap trên canvas? (Giả sử biến bitmap là đối tượng Bitmap, biến paint là đối tượng Paint, biến canvas là đối tượng Canvas, left, top là các biến toạ độ kiểu float).",
    "options": [
      "canvas.drawBitmap(bitmap, left, top, paint);",
      "paint.drawBitmap(bitmap, left, top, canvas);",
      "canvas.drawBitmap(left, top, bitmap, paint);",
      "paint.drawBitmap(left, top, bitmap, canvas);"
    ],
    "answer": 0
  },
  {
    "q": "Phương thức sendDataMessage được dùng khi nào? Các đối số không null.",
    "options": [
      "Gởi dữ liệu bằng tin nhắn SMS, public void sendDataMessage (destinationAddress, null, short destinationPort, byte[] data, null, null)",
      "Gởi dữ liệu bằng tin nhắn MMS, public void sendDataMessage (destinationAddress, scAddress, null, byte[] data, null, null)",
      "Gởi dữ liệu bằng tin nhắn SMS, public void sendDataMessage (destinationAddress, scAddress, short destinationPort, byte[] data, null, null)",
      "Tất cả các câu trả lời khác đều sai."
    ],
    "answer": 2
  },
  {
    "q": "Để xây dựng chương trình nhận tin nhắn, chương trình bao gồm một danh sách hiển thị tất cả tin nhắn trong Inbox, ta sử dụng lớp nào?",
    "options": [
      "ListView",
      "ListArray",
      "ArrayAdaptor",
      "ListActivity"
    ],
    "answer": 3
  },
  {
    "q": "Lớp JSONObject có chức năng gì?",
    "options": [
      "Tạo ra một đối tượng JSON tổng quát.",
      "Lấy một đối tượng JSON ở dạng Object.",
      "Tạo ra đối tượng quản lý JSON ở dạng một Object.",
      "Lấy một đối tượng JSON như một biến."
    ],
    "answer": 0
  },
  {
    "q": "Trong URL sau: http://localhost:8080/myApp?first=joe&last=cool, hãy chọn câu giải thích đúng.",
    "options": [
      "http là giao thức; localhost là host; 8080 là port ; /myApp?first=joe&last=cool là tập tin",
      "http là giao thức; localhost là host; 8080 là port ; /myApp là tập tin ; first=joe&last=cool là các cặp « khóa-giá trị » của yêu cầu.",
      "http là giao thức; localhost là host; 8080 là port ; /myApp là tập tin ; first=joe&last=cool là các thành phần tham khảo.",
      "http là giao thức; localhost là host ; 8080 là địa chỉ ; /myApp là thư mục ; first=joe&last=cool các tập tin."
    ],
    "answer": 1
  },
  {
    "q": "Trong giao thức HTTP, đáp ứng máy chủ gồm các thành phần nào và giải thích?",
    "options": [
      "Gồm 3 thành phần là : dòng trạng thái chỉ ra kết quả của yêu cầu; header chỉ ra thuộc tính của đáp ứng dùng để thông dịch nội dung và body chứa nội dung của đáp ứng.",
      "Gồm 2 thành phần là : dòng trạng thái chỉ ra kết quả của yêu cầu, thuộc tính của đáp ứng dùng để thông dịch nội dung và body chứa nội dung của đáp ứng.",
      "Gồm 4 thành phần là : dòng trạng thái chỉ ra kết quả của yêu cầu; header chỉ ra thuộc tính của đáp ứng dùng để thông dịch nội dung; body chứa nội dung của đáp ứng; footer báo kết thúc đáp ứng.",
      "Gồm 3 thành phần là : header chỉ ra kết quả của yêu cầu và thuộc tính của đáp ứng dùng để thông dịch nội dung , title trình bày tựa đề của đáp ứng và body chứa nội dung của đáp ứng."
    ],
    "answer": 0
  },
  {
    "q": "Trong chu kỳ sống (vòng đời) của ứng dụng: Ứng dụng chỉ được gọi là kết thúc khi nào?",
    "options": [
      "Khi tất cả các Activity trong ứng dụng kết thúc.",
      "Khi gọi phương thức onDetroy().",
      "Khi tất cả các Activity và các thành phần chạy ngầm khác trong ứng dụng kết thúc.",
      "Khi gọi phương thức onDetroy() và sau đó là phương thức finish()."
    ],
    "answer": 2
  },
  {
    "q": "Dùng Intent tường minh (Explicit Intent) để gọi 1 Activity khác từ 1 Activity trong cùng ứng dụng, ta dùng phương thức nào để gởi kèm theo dữ liệu:",
    "options": [
      "putIntent()",
      "putDataIIntent()",
      "pushExtra()",
      "putExtra ()"
    ],
    "answer": 3
  },
  {
    "q": "Android có nhiều Content Provider hữu ích được dựng sẵn như Browser, CallLog, Contacts, MediaStore, Settings. Để truy vấn một Content Provider, chẳng hạn như lấy tất cả các contacts từ một Contacts content provider, chúng ta khai báo như sau:",
    "options": [
      "content://contacts/people",
      "provider://contacts/people",
      "contentprovider://contacts/people",
      "provider://conent/contacts/people"
    ],
    "answer": 0
  },
  {
    "q": "Dữ liệu SQLite được xây dựng trên một ứng dụng Android có đặc điểm như sau:",
    "options": [
      "Có thể truy vấn bởi các ứng dụng khác.",
      "Là dữ liệu dùng riêng cho ứng dụng, chỉ có thể truy vấn bởi ứng dụng đó.",
      "Một phiên bản CSDL có thể dùng cho nhiều phiên bản ứng dụng.",
      "Khi nâng cấp ứng dụng lên phiên bản mới ta không cần thiết phải khai báo phiên bản CSDL mới."
    ],
    "answer": 1
  },
  {
    "q": "Content Provider lưu dữ liệu bằng hình thức nào?",
    "options": [
      "Chỉ lưu bằng tập tin XML hoặc JSON với các cặp khoá-giá trị.",
      "Có thể sử dụng nhiều cách khác nhau để lưu dữ, dữ liệu có thể được lưu giữ trong một cơ sở dữ liệu, một file,…",
      "Chỉ lưu dưới dạng tập tin.",
      "Chỉ lưu dưới dạng cơ sở dữ liệu SQLite."
    ],
    "answer": 1
  },
  {
    "q": "Trong Android có các cách lưu dữ liệu nào?",
    "options": [
      "Trong bộ nhớ trong, thẻ nhớ, trong tài khoản dịch vụ đám mây, dùng cơ sở dữ liệu SQLite, Content Provider.",
      "Bằng đối tượng Sharedpreferences , hoặc Hệ thống tập tin truyền thống, hoặc CSDL SQLite, hoặc Content Provider, hoặc định dạng XML hoặc JSON.",
      "Bằng tập tin XML, tập tin truyền thống, lập trình Java với SQLite, tài nguyên tĩnh, các thiết lập (setting), tập tin JSON.",
      "Trong bộ nhớ trong, thẻ nhớ, trong tài khoản dịch vụ đám mây, dùng cơ sở dữ liệu SQLite, Content Provider, các thiết lập tuỳ chỉnh, tài khoản trên server."
    ],
    "answer": 1
  },
  {
    "q": "Mỗi đối tượng Preference mà người lập trình thêm vào được lưu trữ dưới dạng nào?",
    "options": [
      "Một cặp name-value mà hệ thống dùng để lưu một thiết lập trong một tập tin SharePreferences mặc định.",
      "Một cặp key-data mà hệ thống dùng để lưu một thiết lập trong một tập tin XML mặc định.",
      "Một tập tin XML tương ứng với lớp SharePreferences.",
      "Một cặp key-value mà hệ thống dùng để lưu một thiết lập trong một tập tin SharePreferences mặc định."
    ],
    "answer": 3
  },
  {
    "q": "Để thao tác với cơ sở dữ liệu lưu trữ trên SQLite trên Android ta sử dụng các đối tượng nào?",
    "options": [
      "SQLiteOpenController và SQLiteDatabase",
      "SQLiteOpenHelper và SQLiteDataContent",
      "SQLiteData và SQLiteOpenManager",
      "SQLiteOpenHelper và SQLiteDatabase"
    ],
    "answer": 3
  },
  {
    "q": "Trình bày các bước lập trình để kiểm tra xem điện thoại đang sử dụng loại kết nối nào?",
    "options": [
      "Bước 1:Tạo ra đối tượng quản lý kết nối với lớp ConnectivityHolder. Bước 2:Lấy biến thông tin về mạng với hàm getNetworkInfo(). Bước 3:Lấy thông tin về loại mạng đang kết nối với hàm getType().Bước 4: Viết các lệnh hiển thị thông tin kết nối mạng",
      "Bước 1:Tạo ra đối tượng kết nối với phương thức getconnectivityManager(). Bước 2: Lấy biến thông tin về mạng với hàm getAtiveNetwork(), Bước 3: Lấy thông tin về loại mạng đang kết nối với hàm getTypeInfo(). Bước 4: Viết các lệnh hiển thị thông tin kết nối mạng.",
      "Bước 1:Tạo ra đối tượng kết nối với phương thức getconnectivityManager(). Bước 2: Lấy biến thông tin về mạng với hàm getAtiveNetworkInfo(). Bước 3: Viết các lệnh hiển thị thông tin kết nối mạng.",
      "Bước 1:Tạo ra đối tượng ConnectivityManager với hàm getSystemService.Bước 2:Lấy biến thông tin về mạng với hàm getAtiveNetworkInfo(). Bước 3: Lấy thông tin về loại mạng đang kết nối với hàm getType(). Bước 4:Viết các lệnh hiển thị thông tin kết nối mạng."
    ],
    "answer": 3
  },
  {
    "q": "Các bước thực hiện giao thức HTTP với phương thức GET như sau:",
    "options": [
      "Khởi tạo một đối tượng InputSteam. Mở một kết nối HTTP với một URL từ xa.  Thiết lập các thuộc tính của kết nối. Lấy đáp ứng HTTP_OK để biết kết nối đã được thiết lập hay chưa. Nếu kết nối được thiết lập thì tiến hành lấy đối tượng InputStream từ kết nối để bắt đầu tải dữ liệu từ server.",
      "Tạo ra một đối tượng HttpClient. Tạo ra một đối tượng HttpGet.Thêm vào các yêu yều vào URL. Thiết lập kết nối và lấy đáp ứng từ server.",
      "Tạo ra một đối tượng HttpGet. Lấy đáp ứng HTTP_OK để biết kết nối đã được thiết lập hay chưa.  Nếu kết nối được thiết lập thì tiến hành lấy đối tượng InputStream từ kết nối để bắt đầu tải dữ liệu từ server.",
      "Khởi tạo một đối tượng InputSteam. Mở một kết nối HTTP với một URL từ xa.Lấy đáp ứng HTTP_OK để biết kết nối đã được thiết lập hay chưa.Nếu kết nối được thiết lập thì tiến hành lấy đối tượng InputStream từ kết nối để bắt đầu tải dữ liệu từ server."
    ],
    "answer": 1
  },
  {
    "q": "Visible process là tiến trình của ứng dụng mà:",
    "options": [
      "Activity đang hiển thị đối với người dùng trong thời gian phương thức onPause() được gọi mà sau đó chưa gọi phương thức nào khác.",
      "Activity đang hiển thị đối với người dùng từ lúc phương thức onCreate() được gọi đến phương thức onStop() hoặc onDestroy().",
      "Activity đang hiển thị đối với người dùng từ lúc phương thức onStar() của Activity được gọi đến phương thức onPause() hoặc onStop().",
      "Activity đang hiển thị đối với người dùng từ lúc phương thức onCreate() hoặc onResume() được gọi đến phương thức onStop() hoặc onDestroy()."
    ],
    "answer": 2
  },
  {
    "q": "Nền tảng Android ra mắt vào năm nào?",
    "options": [
      "2005",
      "2006",
      "2008",
      "2007"
    ],
    "answer": 3
  },
  {
    "q": "Máy ảo Java, JVM (Java Virtual Machine), là:",
    "options": [
      "Một phần mềm mô phỏng giúp thử nghiệm các ứng dụng trước khi cho chạy trên thiết bị thật.",
      "Bộ biên dịch mã bytecode, nó có nhiệm vụ chuyển mã bytecode của chương trình Java thành ngôn ngữ máy để chạy trên thiết bị di động.",
      "Bộ chuẩn hóa các chương trình Java cho các thiết bị di động khác nhau có thể có bộ vi xử lý và tập lệnh khác nhau.",
      "Tất cả các câu trả lời khác đều chưa đầy đủ hoặc không đúng."
    ],
    "answer": 1
  },
  {
    "q": "Trong dữ liệu SQLite, để thêm dữ liệu vào bảng ta thực hiện thủ tục gì?",
    "options": [
      "Khai báo 1 đối tượng InitialValues sau đó kết hợp với phương thức put để thêm dữ liệu vào các dòng cho từng cột.",
      "Khai báo 1 đối tượng ContentValues sau đó kết hợp với phương thức add để thêm dữ liệu vào các dòng cho từng cột.",
      "Khai báo 1 đối tượng ContentValues, kết hợp với phương thức put để thêm dữ liệu vào các dòng cho từng cột và sau đó dùng phương thức insert để cập nhật.",
      "Khai báo 1 đối tượng InitialValues, kết hợp với phương thức put để thêm dữ liệu vào các dòng cho từng cột và sau đó dùng phương thức update để cập nhật."
    ],
    "answer": 2
  },
  {
    "q": "Nền tảng (platform) là:",
    "options": [
      "Sự liên kết giữa cấu hình phần cứng, hệ điều hành, ngôn ngữ lập trình và các trừu tượng.",
      "Sự liên kết giữa hệ điều hành và các trừu tượng.",
      "Sự liên kết giữa cấu hình phần cứng và hệ điều hành.",
      "Sự liên kết giữa hệ điều hành, ngôn ngữ lập trình và các trừu tượng."
    ],
    "answer": 0
  },
  {
    "q": "Khung (Frameworks) là:",
    "options": [
      "Một bộ gồm platform, công cụ quản lý cần thiết, ngôn ngữ lập trình, các trừu tượng.",
      "Một bộ gồm môi trường phát triển tích hợp (IDE) và công cụ quản lý cần thiết.",
      "Một bộ gồm môi trường phát triển phần mềm (SDE) và công cụ quản lý cần thiết.",
      "Một môi trường tích hợp (IDE) trên một platform với các công cụ tương ứng."
    ],
    "answer": 1
  },
  {
    "q": "Để khắc phục khó khăn do đa nền tảng (nhà phát triển ứng dụng phải mất nhiều thời gian và công sức lập trình ứng dụng trên các môi trường và ngôn ngữ khác nhau cho các nền tảng khác nhau) người ta đã thực hiện giải pháp sau:",
    "options": [
      "Mã nguồn của ứng dụng được viết bằng một ngôn ngữ nhất định, sau đó được biên dịch sang mã ByteCode và chạy trên máy ảo trong thời gian thực.",
      "Phát triển các môi trường tích hợp chéo (Cross platform hoặc Cross framework).",
      "Phát triển các ứng dụng lai (Hybrid Apps) hoặc sử dụng các môi trường phát triển ứng dụng không cần code.",
      "Tất cả A, B và C đều đúng."
    ],
    "answer": 3
  },
  {
    "q": "Content Provider lưu dữ liệu bằng hình thức nào?",
    "options": [
      "Chỉ lưu bằng tập tin XML hoặc JSON với các cặp khoá-giá trị.",
      "Có thể sử dụng nhiều cách khác nhau để lưu dữ, dữ liệu có thể được lưu giữ trong một cơ sở dữ liệu, một file,…",
      "Chỉ lưu dưới dạng tập tin.",
      "Chỉ lưu dưới dạng cơ sở dữ liệu SQLite."
    ],
    "answer": 1
  },
  {
    "q": "Phương thức sendDataMessage được dùng khi nào? Các đối số không null.",
    "options": [
      "Gởi dữ liệu bằng tin nhắn SMS,public void sendDataMessage ( destinationAddress, null,short destinationPort,byte[] data, null, null)",
      "Gởi dữ liệu bằng tin nhắn MMS,public void sendDataMessage ( destinationAddress, scAddress, null, byte[] data, null, null)",
      "Gởi dữ liệu bằng tin nhắn SMS,public void sendDataMessage ( destinationAddress, scAddress, short destinationPort, byte[] data, null, null)",
      "Tất cả các câu trả lời khác đều sai."
    ],
    "answer": 2
  },
  {
    "q": "Để xây dựng chương trình nhận tin nhắn, chương trình bao gồm một danh sách hiển thị tất cả tin nhắn trong Inbox, ta sử dụng lớp nào?",
    "options": [
      "ListActivity",
      "ListArray",
      "ArrayAdaptor",
      "ListView"
    ],
    "answer": 0
  },
  {
    "q": "Tạo sao khi khai báo thuộc tính text cho một View, người ta khuyên nên khai báo định danh của text sau đó khai báo String của text trong tập tin strings.xml?",
    "options": [
      "Vì khai báo text trong tập tin string.xml hỗ trợ cho việc chuẩn bị sẵn nhiều text để dễ dàng thay đổi text khi cần thiết.",
      "Vì khai báo text trong tập tin string.xml sẽ ít bị lỗi trùng text khi có nhiều View cần khai báo thuộc tính text.",
      "Vì khai báo text trong tập tin string.xml hỗ trợ cho việc thiết kế giao diện đa ngôn ngữ và dễ dàng thay đổi text khi cần thiết.",
      "Tất cả các câu trả lời điều đúng."
    ],
    "answer": 3
  },
  {
    "q": "Trong URL sau:, hãy chọn câu giải thích đúng.",
    "options": [
      "http là giao thức; localhost là host; 8080 là port ; /myApp?first=joe&last=cool là tập tin",
      "http là giao thức; localhost là host; 8080 là port ; /myApp là tập tin ; first=joe&last=cool là các cặp « khóa-giá trị » của yêu cầu.",
      "http là giao thức; localhost là host; 8080 là port ; /myApp là tập tin ; first=joe&last=cool là các thành phần tham khảo.",
      "http là giao thức; localhost là host ; 8080 là địa chỉ ; /myApp là thư mục ; first=joe&last=cool các tập tin."
    ],
    "answer": 1
  },
  {
    "q": "Trong giao thức HTTP, đáp ứng máy chủ gồm các thành phần nào và giải thích?",
    "options": [
      "Gồm 3 thành phần là : dòng trạng thái chỉ ra kết quả của yêu cầu; header chỉ ra thuộc tính của đáp ứng dùng để thông dịch nội dung và body chứa nội dung của đáp ứng.",
      "Gồm 2 thành phần là : dòng trạng thái chỉ ra kết quả của yêu cầu, thuộc tính của đáp ứng dùng để thông dịch nội dung và body chứa nội dung của đáp ứng.",
      "Gồm 4 thành phần là : dòng trạng thái chỉ ra kết quả của yêu cầu; header chỉ ra thuộc tính của đáp ứng dùng để thông dịch nội dung; body chứa nội dung của đáp ứng; footer báo kết thúc đáp ứng.",
      "Gồm 3 thành phần là : header chỉ ra kết quả của yêu cầu và thuộc tính của đáp ứng dùng để thông dịch nội dung , title trình bày tựa đề của đáp ứng và body chứa nội dung của đáp ứng."
    ],
    "answer": 0
  },
  {
    "q": "Lớp JSONObject có chức năng gì?",
    "options": [
      "Tạo ra đối tượng quản lý JSON ở dạng một Object.",
      "Lấy một đối tượng JSON ở dạng Object.",
      "Tạo ra một đối tượng JSON tổng quát.",
      "Lấy một đối tượng JSON như một biến."
    ],
    "answer": 2
  },
  {
    "q": "Để có thể thực hiện các cuộc giao tiếp, một trong hai quá trình phải công bố số hiệu cổng của socket mà mình sử dụng. Ngoài số hiệu cổng, hai bên giao tiếp còn phải biết địa chỉ IP của nhau. Cho biết vai trò của số hiệu cổng và địa chỉ IP.",
    "options": [
      "Số hiệu cổng và IP là một cặp để xác định server hoặc client.",
      "Địa chỉ IP giúp phân biệt các thiết bị trên mạng TCP/IP. Trong khi số hiệu cổng dùng để phân biệt các quá trình khác nhau trên cùng một máy tính.",
      "Cổng đề xác định đường truyền, địa chỉ IP để xác định thiết bị trên mạng TCP/IP.",
      "Số hiệu cổng và địa chỉ IP đều bắt buộc khai báo trong mọi trường hợp cho cả client và server."
    ],
    "answer": 1
  },
  {
    "q": "Dùng Intent tường minh (Explicit Intent) để gọi 1 Activity khác từ 1 Activity trong cùng ứng dụng, ta dùng phương thức nào để gởi kèm theo dữ liệu:",
    "options": [
      "putExtra ()",
      "putDataIIntent()",
      "pushExtra()",
      "putIntent()"
    ],
    "answer": 0
  },
  {
    "q": "Để thao tác với cơ sở dữ liệu lưu trữ trên SQLite trên Android ta sử dụng các đối tượng nào?",
    "options": [
      "SQLiteOpenController và SQLiteDatabase",
      "SQLiteOpenHelper và SQLiteDatabase",
      "SQLiteData và SQLiteOpenManager",
      "SQLiteOpenHelper và SQLiteDataContent"
    ],
    "answer": 1
  },
  {
    "q": "Các phương thức sau đây sẽ giúp lấy chiều rộng và chiều cao của canvas:",
    "options": [
      "getWidth() và getHeight ()",
      "setWidth() và setHeight ()",
      "getCanvasWidth() và getCanvasHeight()",
      "getWidthCanvas() và getHeightCanvas()"
    ],
    "answer": 0
  },
  {
    "q": "Khi sử dụng ListView kết hợp với lớp ListActivity, trong tập tin Layout, phần tử ListView phải khai báo id như sau:",
    "options": [
      "android:id=\"@+id/list\"",
      "android:id=\"@android:id/list\"",
      "android:id=\"@listactivity:id/list\"",
      "Các câu khác với câu này đều sai."
    ],
    "answer": 1
  },
  {
    "q": "Nền tảng (platform) là:",
    "options": [
      "Sự liên kết giữa cấu hình phần cứng, hệ điều hành, ngôn ngữ lập trình và các trừu tượng.",
      "Sự liên kết giữa hệ điều hành và các trừu tượng.",
      "Sự liên kết giữa cấu hình phần cứng và hệ điều hành.",
      "Sự liên kết giữa hệ điều hành, ngôn ngữ lập trình và các trừu tượng."
    ],
    "answer": 0
  },
  {
    "q": "Khung (Frameworks) là:",
    "options": [
      "Một bộ gồm platform, công cụ quản lý cần thiết, ngôn ngữ lập trình, các trừu tượng.",
      "Một bộ gồm môi trường phát triển tích hợp (IDE) và công cụ quản lý cần thiết.",
      "Một bộ gồm môi trường phát triển phần mềm (SDE) và công cụ quản lý cần thiết.",
      "Một môi trường tích hợp (IDE) trên một platform với các công cụ tương ứng."
    ],
    "answer": 3
  },
  {
    "q": "Để khắc phục khó khăn do đa nền tảng (nhà phát triển ứng dụng phải mất nhiều thời gian và công sức lập trình ứng dụng trên các môi trường và ngôn ngữ khác nhau cho các nền tảng khác nhau) người ta đã thực hiện giải pháp sau:",
    "options": [
      "Mã nguồn của ứng dụng được viết bằng một ngôn ngữ nhất định, sau đó được biên dịch sang mã ByteCode và chạy trên máy ảo trong thời gian thực.",
      "Phát triển các môi trường tích hợp chéo (Cross platform hoặc Cross framework).",
      "Phát triển các ứng dụng lai (Hybrid Apps) hoặc sử dụng các môi trường phát triển ứng dụng không cần code.",
      "Tất cả các câu trả lời đều đúng."
    ],
    "answer": 3
  },
  {
    "q": "Khi mở project mới ta cần khai báo chọn bao nhiêu phiên bản, những phiên bản nào? Tại sao?",
    "options": [
      "Cần khai báo 3 phiên bản: 1 để biên dịch (mới nhất, mặc định), 1 phiên bản cũ nhất có thể chạy được ứng dụng và 1 phiên bản trung gian để chạy thử ứng dụng.",
      "Cần khai báo từ 3 phiên bản trở lên: 1 để biên dịch (mới nhất), 1 phiên bản cũ nhất có thể chạy được ứng dụng và các phiên bản trung gian để chạy thử ứng dụng bằng máy ảo.",
      "Cần khai báo 2 phiên bản: 1 để biên dịch (mới nhất, mặc định), 1 phiên bản cũ nhất có thể chạy được ứng dụng.",
      "Cần khai báo 1 phiên bản mới nhất (mặc định)."
    ],
    "answer": 2
  },
  {
    "q": "Kiến trúc Android gồm các tầng nào?",
    "options": [
      "Gồm 5 tầng:Tầng Linux Kernel; Tầng Library; Tầng Android runtime;Tầng Application Framework;Tầng Applications.",
      "Gồm 4 tầng:Tầng Linux Kernel; Tầng Library và Android runtime;Tầng Application Framework;Tầng Applications.",
      "Gồm 3 tầng:Tầng Linux Kernel - Android runtime;Tầng Application Framework;Tầng Applications.",
      "Gồm 4 tầng:Tầng Linux Kernel - Android runtime; Tầng Library;Tầng Application Framework;Tầng Applications."
    ],
    "answer": 1
  },
  {
    "q": "Vai trò và cách tạo một Thread:",
    "options": [
      "Vai trò: sinh ra các tiến trình (luồng) cho một ứng dụng; Cách tạo: Khai báo một lớp kế thừa của lớp Thread và dùng phương thức start() để khởi động tiến trình.",
      "Vai trò: chỉ được dùng để sinh ra các tiến trình (luồng) khi có nhiều tiến trình chạy đồng thời trong một ứng dụng; Cách tạo: Khai báo một lớp kế thừa của lớp Thread và dùng phương thức setcurrent() để khởi động tiến trình.",
      "Vai trò: sinh ra các tiến trình (luồng) có thể chạy đồng thời trong một ứng dụng; Cách tạo: Khai báo một lớp kế thừa của lớp Thread và dùng phương thức run() để khởi động tiến trình.",
      "Tất cả các câu trả lời khác với câu này đều sai."
    ],
    "answer": 0
  },
  {
    "q": "Android cung cấp thêm khả năng lập trình giao diện mức thấp để người lập trình có thể tự do vẽ bất cứ thứ gì mình muốn, để vẽ ta cần phải gọi bốn thành phần cơ bản:",
    "options": [
      "Đối tượng kiểu Image; đối tượng Canvas; đối tượng kiểu Bitmap và đối tượng Graphic.",
      "Đối tượng kiểu Paint; đối tượng Canvas; đối tượng kiểu Bitmap và đối tượng chứa nét vẽ cần vẽ ra (có thể là Rect, Path, Bitmap…).",
      "Đối tượng kiểu Paint; đối tượng SurfaceView; đối tượng kiểu Bitmap và đối tượng chứa nét vẽ cần vẽ ra (có thể là Rect, Path, Bitmap…).",
      "Đối tượng View; đối tượng Canvas; đối tượng kiểu Bitmap và đối tượng chứa nét vẽ cần vẽ ra (có thể là Rect, Path, Bitmap…)."
    ],
    "answer": 1
  },
  {
    "q": "Ngoài vẽ những hình ảnh đơn giản còn có thể vẽ những hình ảnh có sẵn. Android hỗ trợ hình ảnh định dạng PNG, để sử dụng chỉ cần chép vào thư mục drawable là chương trình có thể gọi. Ta có thể dùng câu lệnh như thế nào? Trong các câu trả lời, \"tên\" là tên ảnh png đã lưu trong thư mục drawable và được gọi.",
    "options": [
      "Bitmap bitmap = BitmapFactory(getResources(),R.drawable.tên);",
      "Bitmap bitmap =decodeResource(getResources(),R.drawable.tên);",
      "Bitmap bitmap = Bitmap.decodeResource(getResources(),R.drawable.tên);",
      "Bitmap bitmap = BitmapFactory.decodeResource(getResources(),R.drawable.tên);"
    ],
    "answer": 3
  },
  {
    "q": "Dữ liệu SQLite được xây dựng trên một ứng dụng Android có đặc điểm như sau:",
    "options": [
      "Là dữ liệu dùng riêng cho ứng dụng, chỉ có thể truy vấn bởi ứng dụng đó.",
      "Có thể truy vấn bởi các ứng dụng khác.",
      "Một phiên bản CSDL có thể dùng cho nhiều phiên bản ứng dụng.",
      "Khi nâng cấp ứng dụng lên phiên bản mới ta không cần thiết phải khai báo phiên bản CSDL mới."
    ],
    "answer": 0
  }
]
    ];
  
    // Trạng thái từng chương
    const chapterStates = chapters.map(chapter => ({
      shuffledQuestions: null,
      answered: null,
      current: 0,
      showingAnswer: false,
      comboStreak: 0,
      comboCounted: null,
      isFinished: false
    }));
  
    let currentChapter = 0;
  
    // Tạo Combo Display NỔI BẬT
    const progressElement = document.getElementById("progress");
    const comboContainer = document.createElement("div");
    comboContainer.style.cssText = `
      margin: 12px 0;
      text-align: center;
      font-family: 'Segoe UI', sans-serif;
    `;
  
    const comboDisplay = document.createElement("div");
    comboDisplay.id = "comboDisplay";
    comboDisplay.style.cssText = `
      display: inline-flex;
      align-items: center;
      gap: 10px;
      padding: 10px 18px;
      border-radius: 50px;
      font-weight: bold;
      font-size: 1.1em;
      box-shadow: 0 4px 15px rgba(0,0,0,0.1);
      transition: all 0.4s cubic-bezier(0.175, 0.885, 0.32, 1.275);
      opacity: 0;
      transform: scale(0.8);
    `;
  
    const fireIcon = document.createElement("span");
    fireIcon.id = "fireIcon";
    fireIcon.innerHTML = "";
    fireIcon.style.fontSize = "1.4em";
  
    const comboText = document.createElement("span");
    comboText.id = "comboText";
  
    comboDisplay.appendChild(fireIcon);
    comboDisplay.appendChild(comboText);
    comboContainer.appendChild(comboDisplay);
    progressElement.parentNode.insertBefore(comboContainer, progressElement.nextSibling);
  
    // CSS Animation cho Combo
    const style = document.createElement('style');
    style.textContent = `
      @keyframes pulseFire {
        0%, 100% { transform: scale(1); }
        50% { transform: scale(1.3); }
      }
      @keyframes bounceIn {
        0% { opacity: 0; transform: scale(0.3); }
        50% { opacity: 1; transform: scale(1.1); }
        100% { transform: scale(1); }
      }
      @keyframes shake {
        0%, 100% { transform: translateX(-50%) translateY(0); }
        10%, 30%, 50%, 70%, 90% { transform: translateX(-50%) translateY(-5px); }
        20%, 40%, 60%, 80% { transform: translateX(-50%) translateY(5px); }
      }
      .combo-level-1 { background: linear-gradient(135deg, #ff6b6b, #ff8e8e); color: white; }
      .combo-level-5 { background: linear-gradient(135deg, #ffd93d, #ffbc00); color: #333; animation: pulseFire 1.5s infinite; }
      .combo-level-10 { background: linear-gradient(135deg, #ff4757, #ff6b7d); color: white; animation: pulseFire 1s infinite; box-shadow: 0 0 20px rgba(255,71,87,0.6); }
    `;
    document.head.appendChild(style);
  
    // Gãy chuỗi thông báo
    const breakStreakElement = document.createElement("div");
    breakStreakElement.id = "breakStreak";
    breakStreakElement.style.cssText = `
      position: fixed; top: 20px; left: 50%; transform: translateX(-50%);
      background: #ff4757; color: white; padding: 14px 28px; border-radius: 16px;
      font-weight: bold; font-size: 1.2em; box-shadow: 0 6px 20px rgba(255,71,87,0.5);
      z-index: 1000; opacity: 0; transition: all 0.5s ease; pointer-events: none;
    `;
    document.body.appendChild(breakStreakElement);
  
    function showBreakStreakMessage() {
      breakStreakElement.textContent = "GÃY CHUỖI! Bạn đã thất bại giữ chuỗi trả lời đúng.";
      breakStreakElement.style.opacity = "1";
      breakStreakElement.style.animation = "shake 0.6s ease";
      setTimeout(() => {
        breakStreakElement.style.opacity = "0";
        breakStreakElement.style.animation = "";
      }, 3000);
    }
  
    function updateComboDisplay() {
      const state = getCurrentState();
      if (state.comboStreak === 0) {
        comboDisplay.style.opacity = "0";
        comboDisplay.style.transform = "scale(0.8)";
        return;
      }
  
      // Cập nhật nội dung
      const fireCount = Math.min(state.comboStreak, 15);
      fireIcon.innerHTML = " ".repeat(fireCount);
      comboText.textContent = `Combo: ${state.comboStreak} liên tiếp!`;
  
      // Cập nhật lớp màu
      comboDisplay.className = "";
      if (state.comboStreak >= 10) {
        comboDisplay.classList.add("combo-level-10");
      } else if (state.comboStreak >= 5) {
        comboDisplay.classList.add("combo-level-5");
      } else {
        comboDisplay.classList.add("combo-level-1");
      }
  
      // Hiệu ứng xuất hiện
      comboDisplay.style.opacity = "1";
      comboDisplay.style.transform = "scale(1)";
      comboDisplay.style.animation = "bounceIn 0.5s ease";
    }
  
    function shuffleArray(array) {
      const arr = [...array];
      for (let i = arr.length - 1; i > 0; i--) {
        const j = Math.floor(Math.random() * (i + 1));
        [arr[i], arr[j]] = [arr[j], arr[i]];
      }
      return arr;
    }
  
    function getCurrentState() {
      return chapterStates[currentChapter];
    }
  
    function updateProgress() {
      const state = getCurrentState();
      document.getElementById("progress").textContent =
        `Chương ${currentChapter + 1} - Câu ${state.current + 1}/${state.shuffledQuestions.length} - Còn lại ${state.shuffledQuestions.length - state.current - 1} câu`;
      updateComboDisplay();
    }
  
    function updateQuestionGrid() {
      const state = getCurrentState();
      const grid = document.getElementById("questionGrid");
      let html = "";
      state.shuffledQuestions.forEach((_, i) => {
        const isAnswered = state.answered[i] !== null;
        const isCurrent = i === state.current;
        html += `<div class="grid-item ${isAnswered ? 'answered' : ''} ${isCurrent ? 'current' : ''}" data-index="${i}">${i + 1}</div>`;
      });
      grid.innerHTML = html;
  
      document.querySelectorAll(".grid-item").forEach(item => {
        item.addEventListener("click", () => {
          state.current = parseInt(item.getAttribute("data-index"));
          state.showingAnswer = false;
          loadQuestion();
        });
      });
    }
  
    function loadQuestion() {
      const state = getCurrentState();
      const qBox = document.getElementById("quiz");
      const q = state.shuffledQuestions[state.current];
      let html = `<div class="question">${q.q}</div><div class="options">`;
      q.options.forEach((opt, i) => {
        const checked = state.answered[state.current] === i ? "checked" : "";
        html += `
          <label>
            <input type="radio" name="opt" value="${i}" ${checked}>
            <span>${opt}</span>
          </label>`;
      });
      html += "</div><div id='answerBox'></div>";
      qBox.innerHTML = html;
  
      document.getElementById("prevBtn").disabled = state.current === 0;
      document.getElementById("nextBtn").innerText = state.current === state.shuffledQuestions.length - 1 ? "Kết thúc" : "Tiếp theo";
  
      document.querySelectorAll('input[name="opt"]').forEach(input => {
        input.addEventListener("change", e => {
          state.answered[state.current] = parseInt(e.target.value);
          updateQuestionGrid();
        });
      });
  
      updateProgress();
      updateQuestionGrid();
      state.showingAnswer = false;
    }
  
    function switchChapter(chapterIndex) {
      const prevState = getCurrentState();
      currentChapter = chapterIndex;
  
      if (prevState.isFinished) {
        restoreQuizInterface();
      }
  
      if (!chapterStates[currentChapter].shuffledQuestions) {
        chapterStates[currentChapter].shuffledQuestions = shuffleArray(chapters[currentChapter]);
        chapterStates[currentChapter].answered = Array(chapterStates[currentChapter].shuffledQuestions.length).fill(null);
        chapterStates[currentChapter].comboCounted = Array(chapterStates[currentChapter].shuffledQuestions.length).fill(false);
        chapterStates[currentChapter].current = 0;
        chapterStates[currentChapter].comboStreak = 0;
        chapterStates[currentChapter].isFinished = false;
      }
  
      document.querySelectorAll(".tab").forEach(tab => tab.classList.remove("active"));
      document.querySelector(`.tab[data-chapter="${chapterIndex}"]`).classList.add("active");
  
      loadQuestion();
    }
  
    function restoreQuizInterface() {
      document.querySelector(".quiz-container").innerHTML = `
        <div class="logo">
          <img src="asset/img/dnc.jpg" alt="Logo">
        </div>
        <div class="title">Trắc nghiệm ôn thi</div>
        <div id="progress"></div>
        <div id="combo"></div>
        <div id="quiz"></div>
        <div class="controls">
          <button id="prevBtn">Quay lại</button>
          <button id="nextBtn">Tiếp theo</button>
        </div>
      `;
  
      const newProgress = document.getElementById("progress");
      newProgress.parentNode.insertBefore(comboContainer, newProgress.nextSibling);
  
      document.getElementById("prevBtn").addEventListener("click", () => {
        const state = getCurrentState();
        if (state.current > 0) {
          state.current--;
          loadQuestion();
        }
      });
  
      document.getElementById("nextBtn").addEventListener("click", () => {
        const state = getCurrentState();
        if (!state.showingAnswer) {
          const q = state.shuffledQuestions[state.current];
          const userAns = state.answered[state.current];
          let ansHtml = `
            <div class="answer-box">
              <div>
                <span class="icon">${userAns === q.answer ? "Correct" : "Wrong"}</span>
                Bạn chọn: <span class="${userAns === q.answer ? 'correct' : 'wrong'}">
                  ${userAns !== null ? q.options[userAns] : "(không chọn)"}
                </span>
              </div>
              <div>
                <span class="icon">Correct</span>
                Đáp án đúng: <span class="correct">${q.options[q.answer]}</span>
              </div>
            </div>
          `;
          document.getElementById("answerBox").innerHTML = ansHtml;
          state.showingAnswer = true;
  
          if (userAns === q.answer && userAns !== null && !state.comboCounted[state.current]) {
            state.comboStreak++;
            state.comboCounted[state.current] = true;
          } else if (userAns !== q.answer || userAns === null) {
            if (state.comboStreak > 0) showBreakStreakMessage();
            state.comboStreak = 0;
            state.comboCounted.fill(false);
          }
          updateComboDisplay();
          return;
        }
        if (state.current < state.shuffledQuestions.length - 1) {
          state.current++;
          loadQuestion();
        } else {
          showSummary();
        }
      });
    }
  
    switchChapter(0);
  
    document.querySelectorAll(".tab").forEach(tab => {
      tab.addEventListener("click", () => {
        const chapterIndex = parseInt(tab.getAttribute("data-chapter"));
        if (chapterIndex !== currentChapter) switchChapter(chapterIndex);
      });
    });
  
    document.getElementById("nextBtn").addEventListener("click", () => {
      const state = getCurrentState();
      if (!state.showingAnswer) {
        const q = state.shuffledQuestions[state.current];
        const userAns = state.answered[state.current];
  
        let ansHtml = `
          <div class="answer-box">
            <div>
              <span class="icon">${userAns === q.answer ? "Correct" : "Wrong"}</span>
              Bạn chọn: <span class="${userAns === q.answer ? 'correct' : 'wrong'}">
                ${userAns !== null ? q.options[userAns] : "(không chọn)"}
              </span>
            </div>
            <div>
              <span class="icon">Correct</span>
              Đáp án đúng: <span class="correct">${q.options[q.answer]}</span>
            </div>
          </div>
        `;
        document.getElementById("answerBox").innerHTML = ansHtml;
        state.showingAnswer = true;
  
        if (userAns === q.answer && userAns !== null && !state.comboCounted[state.current]) {
          state.comboStreak++;
          state.comboCounted[state.current] = true;
        } else if (userAns !== q.answer || userAns === null) {
          if (state.comboStreak > 0) showBreakStreakMessage();
          state.comboStreak = 0;
          state.comboCounted.fill(false);
        }
        updateComboDisplay();
        return;
      }
  
      if (state.current < state.shuffledQuestions.length - 1) {
        state.current++;
        loadQuestion();
      } else {
        showSummary();
      }
    });
  
    document.getElementById("prevBtn").addEventListener("click", () => {
      const state = getCurrentState();
      if (state.current > 0) {
        state.current--;
        loadQuestion();
      }
    });
  
    function showSummary() {
      const state = getCurrentState();
      const correct = state.answered.filter((a, i) => a === state.shuffledQuestions[i].answer).length;
  
      const comboHighlight = state.comboStreak > 0 
        ? `<div style="
            font-size: 1.6em; 
            font-weight: bold; 
            color: #ff4757; 
            text-align: center; 
            margin: 20px 0; 
            animation: pulseFire 1.5s infinite;
            text-shadow: 0 0 15px rgba(255,71,87,0.5);
          ">
            Combo cao nhất: ${state.comboStreak} liên tiếp!
          </div>`
        : `<div style="font-size: 1.2em; color: #aaa; text-align: center; margin: 15px 0;">
            Chưa có combo nào!
          </div>`;
  
      let reviewHtml = `
        <div class="summary">Bạn trả lời đúng ${correct}/${state.shuffledQuestions.length} câu!</div>
        ${comboHighlight}
        <div class="review">`;
      state.shuffledQuestions.forEach((q, i) => {
        const userAns = state.answered[i];
        const isCorrect = userAns === q.answer;
        reviewHtml += `
          <div class="answer-block">
            <div class="question">${q.q}</div>
            <div>Bạn chọn: <span class="${isCorrect ? 'correct' : 'wrong'}">${userAns !== null ? q.options[userAns] : "(không chọn)"}</span></div>
            <div>Đáp án đúng: <span class="correct">${q.options[q.answer]}</span></div>
          </div>
        `;
      });
      reviewHtml += `
        </div>
        <div style="text-align:center; margin-top:20px;">
          <button id="restartChapterBtn" style="padding:12px 24px; font-size:1.1em; border-radius:30px; background:#007bff; color:white; border:none; cursor:pointer;">Làm lại chương này</button>
        </div>
      `;
      document.querySelector(".quiz-container").innerHTML = reviewHtml;
  
      state.isFinished = true;
  
      document.getElementById("restartChapterBtn").addEventListener("click", () => {
        chapterStates[currentChapter].shuffledQuestions = shuffleArray([...chapters[currentChapter]]);
        chapterStates[currentChapter].answered = Array(chapterStates[currentChapter].shuffledQuestions.length).fill(null);
        chapterStates[currentChapter].comboCounted = Array(chapterStates[currentChapter].shuffledQuestions.length).fill(false);
        chapterStates[currentChapter].current = 0;
        chapterStates[currentChapter].showingAnswer = false;
        chapterStates[currentChapter].comboStreak = 0;
        chapterStates[currentChapter].isFinished = false;
  
        restoreQuizInterface();
        loadQuestion();
      });
    }
  
    // Khóa DevTools
    (function lockDevTools() {
      document.addEventListener('contextmenu', e => e.preventDefault());
      document.addEventListener('selectstart', e => e.preventDefault());
      document.addEventListener('copy', e => e.preventDefault());
      document.addEventListener('keydown', e => {
        const key = e.key || e.keyCode;
        if (e.key === 'F12' || key === 123 || (e.ctrlKey && e.shiftKey && ['I','J','C'].includes(e.key)) || (e.ctrlKey && ['U','u','S','s'].includes(e.key))) {
          e.preventDefault(); e.stopPropagation(); return false;
        }
      });
      let devtoolsOpen = false;
      const threshold = 160;
      setInterval(() => {
        const open = (window.outerWidth - window.innerWidth > threshold) || (window.outerHeight - window.innerHeight > threshold);
        if (open && !devtoolsOpen) {
          devtoolsOpen = true;
          console.clear();
          console.log("DevTools detected - nội dung bị hạn chế.");
        } else if (!open) devtoolsOpen = false;
      }, 1000);
    })();
  </script>
</body>
</html>